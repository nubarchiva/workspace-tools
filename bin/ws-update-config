#!/bin/bash
# Actualiza configuraci√≥n de AI assistants en worktrees existentes
# √ötil para migrar worktrees creados antes de cambios en la estructura

source "$(dirname "${BASH_SOURCE[0]:-$0}")/ws-init.sh"

# =============================================================================
# Ayuda
# =============================================================================

show_help() {
    echo "Uso: ws update-config [opciones] [workspace]"
    echo ""
    echo "Actualiza la configuraci√≥n de AI assistants en worktrees existentes."
    echo "Genera .claude/CLAUDE.md real (no symlink) para evitar confusi√≥n de working directory."
    echo ""
    echo "Opciones:"
    echo "  --all          Actualizar TODOS los workspaces"
    echo "  --dry-run      Mostrar qu√© se har√≠a sin ejecutar cambios"
    echo "  --force        Sobrescribir .claude/CLAUDE.md existente"
    echo "  --help, -h     Mostrar esta ayuda"
    echo ""
    echo "Ejemplos:"
    echo "  ws update-config 8400              # Actualizar workspace que contenga '8400'"
    echo "  ws update-config --all             # Actualizar todos los workspaces"
    echo "  ws update-config --all --dry-run   # Ver qu√© se actualizar√≠a"
    echo ""
    echo "¬øPor qu√© es necesario?"
    echo "  Claude Code infiere el proyecto desde la ruta de CLAUDE.md."
    echo "  Si CLAUDE.md es un symlink a la ra√≠z, Claude busca c√≥digo all√≠"
    echo "  en lugar del worktree actual. Este comando crea un archivo real"
    echo "  con la ruta correcta del worktree."
}

# =============================================================================
# Parsear argumentos
# =============================================================================

UPDATE_ALL=false
DRY_RUN=false
FORCE=false
WORKSPACE_PATTERN=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --all)
            UPDATE_ALL=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --force)
            FORCE=true
            shift
            ;;
        --help|-h)
            show_help
            exit 0
            ;;
        -*)
            error "Opci√≥n desconocida: $1"
            echo "Usa --help para ver las opciones disponibles"
            exit 1
            ;;
        *)
            if [ -z "$WORKSPACE_PATTERN" ]; then
                WORKSPACE_PATTERN="$1"
            else
                error "Solo se puede especificar un workspace o --all"
                exit 1
            fi
            shift
            ;;
    esac
done

# Validar argumentos
if [ "$UPDATE_ALL" = false ] && [ -z "$WORKSPACE_PATTERN" ]; then
    error "Especifica un workspace o usa --all"
    echo ""
    show_help
    exit 1
fi

if [ "$UPDATE_ALL" = true ] && [ -n "$WORKSPACE_PATTERN" ]; then
    error "No puedes usar --all y especificar un workspace"
    exit 1
fi

# =============================================================================
# Funciones
# =============================================================================

# Actualiza un workspace individual
update_workspace() {
    local workspace_name=$1
    local workspace_dir="$WORKSPACES_DIR/$workspace_name"
    local claude_dir="$workspace_dir/.claude"
    local claude_md="$claude_dir/CLAUDE.md"

    # Verificar que existe
    if [ ! -d "$workspace_dir" ]; then
        warning "Workspace no existe: $workspace_name"
        return 1
    fi

    # Verificar si ya tiene .claude/CLAUDE.md
    local needs_update=false
    local reason=""

    if [ ! -d "$claude_dir" ]; then
        needs_update=true
        reason="no existe .claude/"
    elif [ ! -f "$claude_md" ]; then
        needs_update=true
        reason="no existe CLAUDE.md"
    elif [ -L "$claude_md" ]; then
        needs_update=true
        reason="CLAUDE.md es symlink (deber√≠a ser archivo real)"
    elif [ "$FORCE" = true ]; then
        needs_update=true
        reason="forzado con --force"
    fi

    if [ "$needs_update" = false ]; then
        echo "  ${COLOR_DIM}‚è≠Ô∏è  $workspace_name - ya tiene .claude/CLAUDE.md${COLOR_RESET}"
        return 2  # C√≥digo especial: saltado (no es error, pero tampoco actualizado)
    fi

    if [ "$DRY_RUN" = true ]; then
        echo "  ${COLOR_CYAN}üìù $workspace_name${COLOR_RESET} - se actualizar√≠a ($reason)"
        return 3  # C√≥digo especial: dry-run (se actualizar√≠a)
    fi

    # Crear directorio si no existe
    mkdir -p "$claude_dir"

    # Eliminar symlink si existe
    if [ -L "$claude_md" ]; then
        rm "$claude_md"
    fi

    # Generar CLAUDE.md usando la funci√≥n de ws-common.sh
    _generate_claude_md "$workspace_dir" "$workspace_name" "$WORKSPACE_ROOT"

    success "  ‚úÖ $workspace_name - actualizado ($reason)"
    return 0
}

# =============================================================================
# Ejecuci√≥n principal
# =============================================================================

echo ""
if [ "$DRY_RUN" = true ]; then
    info "üîç Modo dry-run: mostrando qu√© se actualizar√≠a"
else
    info "üîÑ Actualizando configuraci√≥n de AI assistants..."
fi
echo ""

updated=0
skipped=0
would_update=0
errors=0

# Procesa el resultado de update_workspace
# C√≥digos: 0=actualizado, 1=error, 2=saltado, 3=dry-run (se actualizar√≠a)
process_result() {
    local result=$1
    case $result in
        0) ((updated++)) ;;
        1) ((errors++)) ;;
        2) ((skipped++)) ;;
        3) ((would_update++)) ;;
    esac
}

if [ "$UPDATE_ALL" = true ]; then
    # Actualizar todos los workspaces
    if [ ! -d "$WORKSPACES_DIR" ]; then
        error "No existe el directorio de workspaces: $WORKSPACES_DIR"
        exit 1
    fi

    for ws_dir in "$WORKSPACES_DIR"/*; do
        if [ -d "$ws_dir" ]; then
            ws_name=$(basename "$ws_dir")
            update_workspace "$ws_name"
            process_result $?
        fi
    done
else
    # Actualizar workspace espec√≠fico
    WORKSPACE_NAME=$(find_matching_workspace "$WORKSPACE_PATTERN" "$WORKSPACES_DIR")
    if [ $? -ne 0 ]; then
        exit 1
    fi

    update_workspace "$WORKSPACE_NAME"
    process_result $?
fi

echo ""
if [ "$DRY_RUN" = true ]; then
    info "üìä Resumen: $would_update se actualizar√≠a(n), $skipped ya actualizado(s)"
else
    success "üìä Completado: $updated actualizado(s), $skipped ya actualizado(s)"
fi

if [ $errors -gt 0 ]; then
    warning "   $errors error(es)"
fi
