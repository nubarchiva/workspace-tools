#!/bin/bash
# Muestra informaci√≥n de un workspace
# Si se invoca como ws-info: auto-detecta workspace actual
# Si se invoca como ws-switch: lista workspaces si no hay argumentos

# Inicializacion centralizada
source "$(dirname "${BASH_SOURCE[0]:-$0}")/ws-init.sh"
source "$(dirname "${BASH_SOURCE[0]:-$0}")/ws-git-utils.sh"

# Detectar modo de invocaci√≥n (info vs switch)
SCRIPT_NAME=$(basename "$0")
IS_INFO_MODE=false
[[ "$SCRIPT_NAME" == "ws-info" ]] && IS_INFO_MODE=true

# Funci√≥n de ayuda (ajusta textos seg√∫n modo)
show_help() {
    if $IS_INFO_MODE; then
        echo "Uso: ws info [nombre|patr√≥n]"
        echo ""
        echo "Muestra informaci√≥n del workspace (sin cambiar de directorio)."
        echo "Si no se especifica workspace, usa el actual (auto-detecta)."
        echo ""
        echo "üí° Puedes usar coincidencia parcial para el nombre del workspace"
        echo ""
        echo "Ejemplos:"
        echo "  ws info                      # workspace actual (auto-detecta)"
        echo "  ws info master"
        echo "  ws info nuba-8400"
        echo "  ws info fac                  # busca 'fac' en workspaces"
    else
        echo "Uso: ws switch [nombre|patr√≥n]"
        echo ""
        echo "üí° Puedes usar coincidencia parcial para el nombre del workspace"
        echo ""
        echo "Ejemplos:"
        echo "  ws switch                    # lista workspaces disponibles"
        echo "  ws switch master"
        echo "  ws switch nuba-8400"
        echo "  ws switch fac                # busca 'fac' en workspaces"
    fi
}

# Funci√≥n para listar workspaces disponibles
list_available_workspaces() {
    echo "Workspaces disponibles:"
    echo ""

    if [ -d "$WORKSPACES_DIR" ]; then
        for workspace_dir in "$WORKSPACES_DIR"/*; do
            if [ -d "$workspace_dir" ]; then
                workspace_name=$(basename "$workspace_dir")
                branch_name=$(get_branch_name "$workspace_name")
                echo "  ‚Ä¢ ${COLOR_CYAN}$workspace_name${COLOR_RESET} ${COLOR_DIM}(branch: $branch_name)${COLOR_RESET}"
            fi
        done
    fi

    echo ""
    show_help
}

# Manejar opciones de ayuda
if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    show_help
    exit 0
fi

# Determinar workspace: comportamiento diferente seg√∫n modo
WORKSPACE_PATTERN=""

if [ -n "$1" ]; then
    WORKSPACE_PATTERN="$1"
else
    if $IS_INFO_MODE; then
        # Modo info: intentar auto-detectar workspace actual
        WORKSPACE_PATTERN=$(detect_current_workspace 2>/dev/null || true)
        if [ -z "$WORKSPACE_PATTERN" ]; then
            # No se pudo detectar, mostrar lista
            list_available_workspaces
            exit 0
        fi
        info "üîç Workspace detectado: $WORKSPACE_PATTERN"
        echo ""
    else
        # Modo switch: listar workspaces disponibles
        list_available_workspaces
        exit 0
    fi
fi

# Buscar workspace que coincida con el patr√≥n
WORKSPACE_NAME=$(find_matching_workspace "$WORKSPACE_PATTERN" "$WORKSPACES_DIR")
if [ $? -ne 0 ]; then
    exit 1
fi

# Determinar directorio del workspace
WORKSPACE_DIR="$WORKSPACES_DIR/$WORKSPACE_NAME"
BRANCH_NAME="$(get_branch_name "$WORKSPACE_NAME")"

if [ ! -d "$WORKSPACE_DIR" ]; then
    error "‚ùå Workspace no existe: $WORKSPACE_NAME"
    echo ""
    echo "Workspaces disponibles:"
    $0
    exit 1
fi

# Mostrar informaci√≥n del workspace
print_header "Workspace: ${COLOR_BOLD}$WORKSPACE_NAME${COLOR_RESET}"

# Mostrar indicador de modo offline
if ws_is_offline_mode; then
    echo "${COLOR_YELLOW}[OFFLINE]${COLOR_RESET} ${COLOR_DIM}Datos locales (sin fetch)${COLOR_RESET}"
fi
echo ""

# Mostrar estado de cada repo (incluyendo subdirectorios)
echo "Estado de los repos:"
echo ""

repos=$(find_repos_in_workspace "$WORKSPACE_DIR")
has_repos=false

echo "$repos" | while read -r repo_rel_path; do
    if [ -n "$repo_rel_path" ]; then
        has_repos=true
        worktree_path="$WORKSPACE_DIR/$repo_rel_path"

        if [ -d "$worktree_path" ]; then
            echo "üì¶ ${COLOR_CYAN}$repo_rel_path${COLOR_RESET}:"
            cd "$worktree_path"

            # Branch actual
            current_branch=$(git branch --show-current)
            echo "   Branch: ${COLOR_CYAN}$current_branch${COLOR_RESET}"

            # Estado de cambios locales
            if git_has_uncommitted_changes "$worktree_path"; then
                warning "   ‚ö†Ô∏è  Cambios sin commitear:"
                git status -s | sed 's/^/      /'
            else
                success "   ‚úÖ Sin cambios"
            fi

            # Estado de sincronizaci√≥n (solo si no es master/develop)
            if [[ "$WORKSPACE_NAME" != "master" && "$WORKSPACE_NAME" != "develop" ]]; then
                # Determinar branch base (develop o master)
                base_branch=""
                if git rev-parse --verify "origin/develop" >/dev/null 2>&1; then
                    base_branch="origin/develop"
                elif git rev-parse --verify "develop" >/dev/null 2>&1; then
                    base_branch="develop"
                elif git rev-parse --verify "origin/master" >/dev/null 2>&1; then
                    base_branch="origin/master"
                elif git rev-parse --verify "master" >/dev/null 2>&1; then
                    base_branch="master"
                fi

                if [ -n "$base_branch" ]; then
                    # Hacer fetch si hay conectividad
                    git_fetch_if_reachable "$worktree_path"

                    base_name="${base_branch#origin/}"

                    # Calcular los 3 indicadores:
                    # ‚Üë = commits locales sin push
                    # ‚Üê = commits pusheados pero no en develop
                    # ‚Üì = commits de develop que faltan

                    unpushed=0
                    pending_merge=0
                    behind=0

                    # Commits de develop que no tenemos
                    behind=$(git rev-list --count "HEAD..$base_branch" 2>/dev/null || echo "0")

                    # Verificar si tiene upstream (branch remota)
                    upstream=$(git rev-parse --abbrev-ref "@{upstream}" 2>/dev/null)

                    if [ -n "$upstream" ]; then
                        # Commits locales sin push (--first-parent para no contar commits de merges)
                        unpushed=$(git rev-list --count --first-parent "$upstream..HEAD" 2>/dev/null || echo "0")
                        # Commits pusheados pero no en develop
                        pending_merge=$(git rev-list --count "$base_branch..$upstream" 2>/dev/null || echo "0")
                    else
                        # Sin upstream: todos los commits adelante de develop son unpushed
                        unpushed=$(git rev-list --count --first-parent "$base_branch..HEAD" 2>/dev/null || echo "0")
                    fi

                    # Mostrar indicadores con descripci√≥n
                    has_sync_info=false

                    if [ "$unpushed" -gt 0 ]; then
                        echo "   ${COLOR_YELLOW}‚Üë $unpushed commit(s) sin push${COLOR_RESET}"
                        has_sync_info=true
                    fi

                    if [ "$pending_merge" -gt 0 ]; then
                        echo "   ${COLOR_CYAN}‚Üê $pending_merge commit(s) pendiente(s) de merge a $base_name${COLOR_RESET}"
                        has_sync_info=true
                    fi

                    if [ "$behind" -gt 0 ]; then
                        echo "   ${COLOR_MAGENTA}‚Üì $behind commit(s) nuevo(s) en $base_name${COLOR_RESET}"
                        has_sync_info=true
                    fi

                    if [ "$has_sync_info" = false ]; then
                        echo "   ${COLOR_DIM}‚ÜîÔ∏è  Sincronizado con $base_name${COLOR_RESET}"
                    fi
                fi
            else
                # Para master/develop, solo verificar commits sin push
                if git_has_unpushed_commits "$worktree_path"; then
                    unpushed=$(git_count_unpushed_commits "$worktree_path")
                    if git_has_upstream "$worktree_path"; then
                        echo "   ${COLOR_YELLOW}‚Üë $unpushed commit(s) sin push${COLOR_RESET}"
                    else
                        echo "   ${COLOR_YELLOW}‚Üë $unpushed commit(s) sin remoto${COLOR_RESET}"
                    fi
                fi
            fi
            echo ""
        fi
    fi
done

if [ -z "$repos" ] || [ "$repos" = "" ]; then
    echo "  ${COLOR_DIM}(No hay repos en este workspace)${COLOR_RESET}"
    info "  üí° Usa 'ws add $WORKSPACE_NAME <repo>' para a√±adir"
    echo ""
fi

echo ""

# Calcular ruta a mostrar (relativa si es WS_STATUS_MODE, absoluta si no)
if [ -n "$WS_STATUS_MODE" ]; then
    # Modo status: mostrar ruta relativa desde directorio actual
    DISPLAY_PATH=$(realpath --relative-to="$(pwd)" "$WORKSPACE_DIR" 2>/dev/null || echo "$WORKSPACE_DIR")
    echo "üìÅ Ruta: ${COLOR_CYAN}$DISPLAY_PATH${COLOR_RESET}"
    echo ""
    echo "Para trabajar aqu√≠:"
    echo "  ${COLOR_CYAN}cd $DISPLAY_PATH${COLOR_RESET}"
    echo ""

    if [ -n "$repos" ]; then
        echo "O con un repo espec√≠fico:"
        echo "$repos" | while read -r repo_rel_path; do
            if [ -n "$repo_rel_path" ]; then
                REPO_DISPLAY_PATH=$(realpath --relative-to="$(pwd)" "$WORKSPACE_DIR/$repo_rel_path" 2>/dev/null || echo "$WORKSPACE_DIR/$repo_rel_path")
                echo "  ${COLOR_DIM}cd $REPO_DISPLAY_PATH${COLOR_RESET}"
            fi
        done
    fi
else
    # Modo switch normal: mostrar ruta absoluta
    echo "üìÅ Ruta: ${COLOR_CYAN}$WORKSPACE_DIR${COLOR_RESET}"
    echo ""
    echo "Para trabajar aqu√≠:"
    echo "  ${COLOR_CYAN}cd $WORKSPACE_DIR${COLOR_RESET}"
    echo ""

    if [ -n "$repos" ]; then
        echo "O con un repo espec√≠fico:"
        echo "$repos" | while read -r repo_rel_path; do
            if [ -n "$repo_rel_path" ]; then
                echo "  ${COLOR_DIM}cd $WORKSPACE_DIR/$repo_rel_path${COLOR_RESET}"
            fi
        done
    fi
fi
