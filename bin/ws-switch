#!/bin/bash
# Cambia al workspace especificado y muestra su informaci√≥n

# Inicializacion centralizada
source "$(dirname "${BASH_SOURCE[0]:-$0}")/ws-init.sh"

WORKSPACE_PATTERN=$1

# Funci√≥n de ayuda
show_help() {
    echo "Uso: ws switch [nombre|patr√≥n]"
    echo ""
    echo "üí° Puedes usar coincidencia parcial para el nombre del workspace"
    echo ""
    echo "Ejemplos:"
    echo "  ws switch                    # lista workspaces disponibles"
    echo "  ws switch master"
    echo "  ws switch nuba-8400"
    echo "  ws switch fac                # busca 'fac' en workspaces"
}

# Si no hay argumentos, listar workspaces
if [ -z "$WORKSPACE_PATTERN" ]; then
    echo "Workspaces disponibles:"
    echo ""

    if [ -d "$WORKSPACES_DIR" ]; then
        for workspace_dir in "$WORKSPACES_DIR"/*; do
            if [ -d "$workspace_dir" ]; then
                workspace_name=$(basename "$workspace_dir")
                branch_name=$(get_branch_name "$workspace_name")
                echo "  ‚Ä¢ ${COLOR_CYAN}$workspace_name${COLOR_RESET} ${COLOR_DIM}(branch: $branch_name)${COLOR_RESET}"
            fi
        done
    fi

    echo ""
    show_help
    exit 0
fi

# Buscar workspace que coincida con el patr√≥n
WORKSPACE_NAME=$(find_matching_workspace "$WORKSPACE_PATTERN" "$WORKSPACES_DIR")
if [ $? -ne 0 ]; then
    exit 1
fi

# Determinar directorio del workspace
WORKSPACE_DIR="$WORKSPACES_DIR/$WORKSPACE_NAME"
BRANCH_NAME="$(get_branch_name "$WORKSPACE_NAME")"

if [ ! -d "$WORKSPACE_DIR" ]; then
    error "‚ùå Workspace no existe: $WORKSPACE_NAME"
    echo ""
    echo "Workspaces disponibles:"
    $0
    exit 1
fi

# Mostrar informaci√≥n del workspace
print_header "Workspace: ${COLOR_BOLD}$WORKSPACE_NAME${COLOR_RESET}"
echo ""

# Mostrar estado de cada repo (incluyendo subdirectorios)
echo "Estado de los repos:"
echo ""

repos=$(find_repos_in_workspace "$WORKSPACE_DIR")
has_repos=false

echo "$repos" | while read -r repo_rel_path; do
    if [ -n "$repo_rel_path" ]; then
        has_repos=true
        worktree_path="$WORKSPACE_DIR/$repo_rel_path"

        if [ -d "$worktree_path" ]; then
            echo "üì¶ ${COLOR_CYAN}$repo_rel_path${COLOR_RESET}:"
            cd "$worktree_path"

            # Branch actual
            current_branch=$(git branch --show-current)
            echo "   Branch: ${COLOR_CYAN}$current_branch${COLOR_RESET}"

            # Estado de cambios locales
            if git_has_uncommitted_changes "$worktree_path"; then
                warning "   ‚ö†Ô∏è  Cambios sin commitear:"
                git status -s | sed 's/^/      /'
            else
                success "   ‚úÖ Sin cambios"
            fi

            # Estado de sincronizaci√≥n (solo si no es master/develop)
            if [[ "$WORKSPACE_NAME" != "master" && "$WORKSPACE_NAME" != "develop" ]]; then
                # Determinar branch base (develop o master)
                base_branch=""
                if git rev-parse --verify "origin/develop" >/dev/null 2>&1; then
                    base_branch="origin/develop"
                elif git rev-parse --verify "develop" >/dev/null 2>&1; then
                    base_branch="develop"
                elif git rev-parse --verify "origin/master" >/dev/null 2>&1; then
                    base_branch="origin/master"
                elif git rev-parse --verify "master" >/dev/null 2>&1; then
                    base_branch="master"
                fi

                if [ -n "$base_branch" ]; then
                    # Hacer fetch silencioso para tener refs actualizadas
                    git fetch origin --quiet 2>/dev/null || true

                    base_name="${base_branch#origin/}"

                    # Calcular los 3 indicadores:
                    # ‚Üë = commits locales sin push
                    # ‚Üê = commits pusheados pero no en develop
                    # ‚Üì = commits de develop que faltan

                    unpushed=0
                    pending_merge=0
                    behind=0

                    # Commits de develop que no tenemos
                    behind=$(git rev-list --count "HEAD..$base_branch" 2>/dev/null || echo "0")

                    # Verificar si tiene upstream (branch remota)
                    upstream=$(git rev-parse --abbrev-ref "@{upstream}" 2>/dev/null)

                    if [ -n "$upstream" ]; then
                        # Commits locales sin push
                        unpushed=$(git rev-list --count "$upstream..HEAD" 2>/dev/null || echo "0")
                        # Commits pusheados pero no en develop
                        pending_merge=$(git rev-list --count "$base_branch..$upstream" 2>/dev/null || echo "0")
                    else
                        # Sin upstream: todos los commits adelante de develop son unpushed
                        unpushed=$(git rev-list --count "$base_branch..HEAD" 2>/dev/null || echo "0")
                    fi

                    # Mostrar indicadores con descripci√≥n
                    has_sync_info=false

                    if [ "$unpushed" -gt 0 ]; then
                        echo "   ${COLOR_YELLOW}‚Üë $unpushed commit(s) sin push${COLOR_RESET}"
                        has_sync_info=true
                    fi

                    if [ "$pending_merge" -gt 0 ]; then
                        echo "   ${COLOR_CYAN}‚Üê $pending_merge commit(s) pendiente(s) de merge a $base_name${COLOR_RESET}"
                        has_sync_info=true
                    fi

                    if [ "$behind" -gt 0 ]; then
                        echo "   ${COLOR_MAGENTA}‚Üì $behind commit(s) nuevo(s) en $base_name${COLOR_RESET}"
                        has_sync_info=true
                    fi

                    if [ "$has_sync_info" = false ]; then
                        echo "   ${COLOR_DIM}‚ÜîÔ∏è  Sincronizado con $base_name${COLOR_RESET}"
                    fi
                fi
            else
                # Para master/develop, solo verificar commits sin push
                if git_has_unpushed_commits "$worktree_path"; then
                    unpushed=$(git_count_unpushed_commits "$worktree_path")
                    if git_has_upstream "$worktree_path"; then
                        echo "   ${COLOR_YELLOW}‚Üë $unpushed commit(s) sin push${COLOR_RESET}"
                    else
                        echo "   ${COLOR_YELLOW}‚Üë $unpushed commit(s) sin remoto${COLOR_RESET}"
                    fi
                fi
            fi
            echo ""
        fi
    fi
done

if [ -z "$repos" ] || [ "$repos" = "" ]; then
    echo "  ${COLOR_DIM}(No hay repos en este workspace)${COLOR_RESET}"
    info "  üí° Usa 'ws add $WORKSPACE_NAME <repo>' para a√±adir"
    echo ""
fi

echo ""

# Calcular ruta a mostrar (relativa si es WS_STATUS_MODE, absoluta si no)
if [ -n "$WS_STATUS_MODE" ]; then
    # Modo status: mostrar ruta relativa desde directorio actual
    DISPLAY_PATH=$(realpath --relative-to="$(pwd)" "$WORKSPACE_DIR" 2>/dev/null || echo "$WORKSPACE_DIR")
    echo "üìÅ Ruta: ${COLOR_CYAN}$DISPLAY_PATH${COLOR_RESET}"
    echo ""
    echo "Para trabajar aqu√≠:"
    echo "  ${COLOR_CYAN}cd $DISPLAY_PATH${COLOR_RESET}"
    echo ""

    if [ -n "$repos" ]; then
        echo "O con un repo espec√≠fico:"
        echo "$repos" | while read -r repo_rel_path; do
            if [ -n "$repo_rel_path" ]; then
                REPO_DISPLAY_PATH=$(realpath --relative-to="$(pwd)" "$WORKSPACE_DIR/$repo_rel_path" 2>/dev/null || echo "$WORKSPACE_DIR/$repo_rel_path")
                echo "  ${COLOR_DIM}cd $REPO_DISPLAY_PATH${COLOR_RESET}"
            fi
        done
    fi
else
    # Modo switch normal: mostrar ruta absoluta
    echo "üìÅ Ruta: ${COLOR_CYAN}$WORKSPACE_DIR${COLOR_RESET}"
    echo ""
    echo "Para trabajar aqu√≠:"
    echo "  ${COLOR_CYAN}cd $WORKSPACE_DIR${COLOR_RESET}"
    echo ""

    if [ -n "$repos" ]; then
        echo "O con un repo espec√≠fico:"
        echo "$repos" | while read -r repo_rel_path; do
            if [ -n "$repo_rel_path" ]; then
                echo "  ${COLOR_DIM}cd $WORKSPACE_DIR/$repo_rel_path${COLOR_RESET}"
            fi
        done
    fi
fi
