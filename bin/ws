#!/bin/bash
# Workspace Tools - Comando principal
# Dispatcher para los subcomandos de workspace management

# Detectar directorio del script (compatible bash/zsh)
if [ -n "$BASH_SOURCE" ]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
else
    SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
fi

# Cargar colores para la ayuda
source "$SCRIPT_DIR/ws-colors.sh" 2>/dev/null || true

# Subcomando (primer argumento)
SUBCOMMAND=$1

# Función de ayuda
show_help() {
    print_header "Workspace Tools" 2>/dev/null || {
        echo "╔════════════════════════════════════════════════════╗"
        echo "║  Workspace Tools                                   ║"
        echo "║  Gestión de workspaces con Git worktrees          ║"
        echo "╚════════════════════════════════════════════════════╝"
    }
    cat <<'EOF'

Uso: ws <comando> [argumentos...]

GESTIÓN DE WORKSPACES:

  new <nombre> [--template <tpl>] [repo1] [repo2] ...
      Crea un workspace nuevo con los repos especificados
      Ejemplos:
        ws new feature-123 repo1 libs/lib1
        ws new feature-123 --template frontend
        ws new feature-123 -t backend libs/extra

  list [patrón] (ls)
      Lista todos los workspaces activos (opcionalmente filtrados)
      Ejemplos:
        ws list                        # todos los workspaces
        ws ls 8089                     # solo los que contienen "8089"
        ws ls NUBA                     # solo los que contienen "NUBA"

  switch <workspace> (cd)
      Muestra información del workspace
      Con 'ws cd' cambia automáticamente al directorio
      Ejemplos:
        ws switch feature-123
        ws cd feature-123              # cambia al directorio

  rename <actual> <nuevo> (mv)
      Renombra un workspace (directorio + branches + worktrees)
      Verificaciones: sin cambios pendientes, advertencias claras
      Ejemplos:
        ws rename feature-123 feature-456
        ws mv old-name new-name        # alias corto

  status [workspace] (st, ., here)
      Muestra el estado del workspace actual (auto-detecta)
      Ejemplos:
        ws status                      # desde dentro de un workspace
        ws .                           # atajo corto
        ws status feature-123          # desde cualquier lugar

  info <workspace>
      Muestra información del workspace (sin cambiar directorio)
      Ejemplo: ws info feature-123

  clean <workspace> (rm)
      Elimina un workspace completo (worktrees + directorio)
      Ejemplo: ws clean feature-123

GESTIÓN DE REPOS EN WORKSPACE:

  add <workspace> <repo1> [repo2] ...
      Añade repos a un workspace existente
      Ejemplo: ws add feature-123 libs/lib1 modules/mod1

  remove <workspace> <repo1> [repo2] ...
      Elimina repos de un workspace (verifica cambios pendientes)
      Ejemplo: ws remove feature-123 libs/lib1

OPERACIONES MULTI-REPO:

  mvn <workspace> <args>
      Ejecuta Maven en todos los repos del workspace
      Ejemplo: ws mvn feature-123 clean install

  git <workspace> <comando> [args]
      Ejecuta Git en todos los repos del workspace
      Ejemplo: ws git feature-123 status

  sync [workspace] [--fetch|-f] [--rebase|-r]
      Sincroniza todos los repos con el remoto (git pull)
      Opciones: --fetch (solo fetch), --rebase (pull con rebase)
      Ejemplo: ws sync feature-123

  stash [acción] [workspace]
      Gestiona stash coordinado en todos los repos
      Acciones: push (default), pop, list, clear, show
      Ejemplo: ws stash push "WIP: feature"

  grep <patrón> [workspace] [opciones]
      Busca texto o patrones en todos los repos
      Opciones: -i (case-insensitive), -l (solo archivos), --type <ext>
      Ejemplos:
        ws grep "SearchTerm"
        ws grep -i "todo" --type java

  templates [acción] [args]
      Gestiona templates predefinidos de repos
      Acciones: list (default), show, add, remove
      Ejemplos:
        ws templates                        # lista templates
        ws templates add frontend ks-nuba libs/ui
        ws tpl show backend                 # alias

CARACTERÍSTICAS:

  • Búsqueda parcial: usa parte del nombre (ej: ws cd fea)
  • Abreviaturas: n (new), a (add), ls (list), cd (switch), rm (clean)
  • Nombres especiales: master, develop (usan esas branches)
  • Otros nombres: crean branch feature/<nombre>

EJEMPLOS:

  ws new api-v2 repo1 libs/api         # Crear workspace
  ws add api-v2 modules/docs           # Añadir repo
  ws mvn api-v2 clean install          # Compilar todos
  ws git api-v2 status                 # Ver estado
  ws remove api-v2 modules/docs        # Quitar repo
  ws clean api-v2                      # Limpiar workspace

DOCUMENTACIÓN:

  README.md       - Guía completa
  QUICKSTART.md   - Inicio rápido
  CHEATSHEET.md   - Referencia rápida
  EJEMPLOS.md     - Casos de uso

EOF
}

# Si no hay argumentos, mostrar ayuda
if [ -z "$SUBCOMMAND" ]; then
    show_help
    exit 0
fi

# Función para expandir abreviaturas
expand_abbreviation() {
    local abbrev=$1
    local commands="new add remove switch list clean mvn git sync stash grep templates status rename info help"

    # Aliases predefinidos
    case $abbrev in
        ls) echo "list"; return 0 ;;
        rm|del) echo "clean"; return 0 ;;
        cd|sw) echo "switch"; return 0 ;;
        mk|create) echo "new"; return 0 ;;
        mv) echo "rename"; return 0 ;;
        tpl) echo "templates"; return 0 ;;
        .|here|st) echo "status"; return 0 ;;
        h) echo "help"; return 0 ;;
    esac

    # Expansión automática por coincidencia parcial
    local matches=()
    for cmd in $commands; do
        if [[ "$cmd" == "$abbrev"* ]]; then
            matches+=("$cmd")
        fi
    done

    # Analizar resultados
    if [ ${#matches[@]} -eq 0 ]; then
        # No hay coincidencias, devolver el original
        echo "$abbrev"
        return 1
    elif [ ${#matches[@]} -eq 1 ]; then
        # Una sola coincidencia, expandir
        echo "${matches[0]}"
        return 0
    else
        # Múltiples coincidencias, error ambiguo
        echo "❌ Comando ambiguo: '$abbrev' coincide con: ${matches[*]}" >&2
        return 1
    fi
}

# Expandir abreviatura
EXPANDED=$(expand_abbreviation "$SUBCOMMAND")
if [ $? -eq 0 ]; then
    SUBCOMMAND="$EXPANDED"
fi

# Mapear subcomandos a scripts
case $SUBCOMMAND in
    new|add|remove|switch|list|clean|mvn|git|sync|stash|grep|templates|status|rename|info)
        SCRIPT_NAME="ws-$SUBCOMMAND"
        SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_NAME"

        # Verificar que el script existe
        if [ ! -f "$SCRIPT_PATH" ]; then
            echo "❌ Error: comando '$SUBCOMMAND' no encontrado"
            echo ""
            show_help
            exit 1
        fi

        # Ejecutar el script correspondiente, pasando todos los argumentos excepto el primero
        shift
        exec "$SCRIPT_PATH" "$@"
        ;;
    
    help|--help|-h)
        show_help
        exit 0
        ;;

    version|--version|-v|-V)
        VERSION_FILE="$SCRIPT_DIR/../VERSION"
        if [ -f "$VERSION_FILE" ]; then
            echo "workspace-tools $(cat "$VERSION_FILE" | tr -d '\n')"
        else
            echo "workspace-tools (versión desconocida)"
        fi
        exit 0
        ;;

    *)
        echo "❌ Comando desconocido: $SUBCOMMAND"
        echo "   Usa 'ws help' para ver los comandos disponibles"
        exit 1
        ;;
esac
