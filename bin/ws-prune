#!/bin/bash
#
# ws-prune - Limpia ramas locales hu√©rfanas (sin remoto)
#
# Uso: ws prune [opciones] [repo...]
#
# Opciones:
#   --dry-run    Muestra qu√© se borrar√≠a sin borrar nada
#   --force      Borra incluso ramas no mergeadas (¬°PELIGRO!)
#   --all        Aplica a todos los repos del workspace
#   -h, --help   Muestra esta ayuda
#

# Inicializacion centralizada
source "$(dirname "${BASH_SOURCE[0]:-$0}")/ws-init.sh"

# Opciones
DRY_RUN=false
FORCE=false
ALL_REPOS=false
REPOS=()

show_help() {
    cat << 'EOF'
ws prune - Limpia ramas locales innecesarias

USO:
    ws prune [opciones] [repo...]

DESCRIPCI√ìN:
    Elimina ramas locales que ya est√°n mergeadas en develop/main.
    Incluye ramas hu√©rfanas (remoto borrado) y ramas sin cambios.

OPCIONES:
    --dry-run    Muestra qu√© se borrar√≠a sin borrar nada
    --force      Borra incluso ramas no mergeadas (¬°PELIGRO!)
    --all        Aplica a todos los repos del workspace
    -h, --help   Muestra esta ayuda

EJEMPLOS:
    ws prune                    # Limpia repo actual
    ws prune --dry-run          # Ver qu√© se borrar√≠a
    ws prune --all              # Limpia todos los repos
    ws prune --force ks-nuba    # Incluye ramas no mergeadas
    ws prune --all --dry-run    # Ver qu√© se borrar√≠a en todos

PROTECCIONES:
    NO se borran:
    - master, main, develop
    - Rama actual
    - Ramas en uso por worktrees

    Sin --force, solo se borran ramas mergeadas (seguro).
    Con --force se borran TODAS excepto las protegidas.
EOF
}

# Parsear argumentos
while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --force)
            FORCE=true
            shift
            ;;
        --all)
            ALL_REPOS=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -*)
            error "Opci√≥n desconocida: $1"
            echo "Usa 'ws prune --help' para ver opciones disponibles"
            exit 1
            ;;
        *)
            REPOS+=("$1")
            shift
            ;;
    esac
done

# Funci√≥n para detectar el repo actual desde el directorio de trabajo
detect_current_repo() {
    local current_dir="$(pwd)"

    # Si estamos dentro de WORKSPACE_ROOT
    if [[ "$current_dir" == "$WORKSPACE_ROOT"/* ]]; then
        # Extraer ruta relativa
        local rel_path="${current_dir#$WORKSPACE_ROOT/}"

        # Buscar el repo m√°s cercano subiendo en la jerarqu√≠a
        local check_dir="$current_dir"
        while [[ "$check_dir" != "$WORKSPACE_ROOT" && "$check_dir" != "/" ]]; do
            if [[ -d "$check_dir/.git" ]] || [[ -f "$check_dir/.git" ]]; then
                # Encontrado un repo, devolver ruta relativa desde WORKSPACE_ROOT
                echo "${check_dir#$WORKSPACE_ROOT/}"
                return 0
            fi
            check_dir="$(dirname "$check_dir")"
        done
    fi

    return 1
}

# Determinar repos a procesar
if $ALL_REPOS; then
    # Buscar todos los repos principales (no worktrees)
    # Los repos principales tienen .git como directorio, los worktrees tienen .git como archivo
    REPOS=()
    while IFS= read -r -d '' gitdir; do
        if [[ -d "$gitdir" ]]; then  # Solo directorios .git (repos principales)
            repo_dir="$(dirname "$gitdir")"
            repo_name="${repo_dir#$WORKSPACE_ROOT/}"
            # Excluir workspaces (est√°n en workspaces/)
            if [[ "$repo_name" != workspaces/* ]]; then
                REPOS+=("$repo_name")
            fi
        fi
    done < <(find "$WORKSPACE_ROOT" -maxdepth 3 -name ".git" -print0 2>/dev/null)
elif [ ${#REPOS[@]} -eq 0 ]; then
    # Usar repo actual si estamos en uno
    CURRENT_REPO=$(detect_current_repo)
    if [ -n "$CURRENT_REPO" ]; then
        REPOS=("$CURRENT_REPO")
    else
        error "No est√°s en un repositorio. Usa --all o especifica repos."
        exit 1
    fi
fi

# Funci√≥n para limpiar un repo
prune_repo() {
    local repo_path="$1"
    local repo_name="$2"

    if [[ ! -d "$repo_path/.git" ]] && [[ ! -f "$repo_path/.git" ]]; then
        warning "  ‚ö†Ô∏è  $repo_name: No es un repositorio git"
        return 0
    fi

    cd "$repo_path" || return 1

    # Primero, actualizar referencias remotas
    git fetch --prune --quiet 2>/dev/null || true

    # Detectar rama base (develop o main)
    local base_branch="develop"
    if ! git rev-parse --verify develop &>/dev/null; then
        if git rev-parse --verify main &>/dev/null; then
            base_branch="main"
        else
            base_branch="master"
        fi
    fi

    # Rama actual (no se puede borrar)
    local current_branch
    current_branch=$(git branch --show-current 2>/dev/null)

    # Buscar ramas candidatas a limpiar
    local clean_branches=()      # Sin cambios, seguras de borrar
    local with_changes=()        # Con cambios, requieren --force

    while IFS= read -r branch; do
        [ -z "$branch" ] && continue
        # Saltar rama actual
        [[ "$branch" == "$current_branch" ]] && continue
        # Saltar ramas base
        [[ "$branch" == "master" || "$branch" == "main" || "$branch" == "develop" ]] && continue
        # Saltar ramas en uso por worktrees (marcadas con +)
        git branch 2>/dev/null | grep -q "^+ *${branch}$" && continue

        # Contar commits √∫nicos respecto a base_branch
        local unique_commits
        unique_commits=$(git rev-list --count "$base_branch".."$branch" 2>/dev/null || echo "0")

        # Verificar tracking remoto
        local tracking_info=""
        if ! git branch -vv 2>/dev/null | grep "^[* ]*${branch} " | grep -q '\[origin/'; then
            tracking_info=" (sin remote)"
        elif git branch -vv 2>/dev/null | grep "^[* ]*${branch} " | grep -q ': gone]'; then
            tracking_info=" (remote borrado)"
        fi

        if [ "$unique_commits" -eq 0 ]; then
            clean_branches+=("$branch|$tracking_info")
        else
            with_changes+=("$branch|$unique_commits|$tracking_info")
        fi
    done < <(git branch --format='%(refname:short)' 2>/dev/null)

    # Mostrar resultados
    local total_clean=${#clean_branches[@]}
    local total_changes=${#with_changes[@]}

    if [ $total_clean -eq 0 ] && [ $total_changes -eq 0 ]; then
        success "  ‚úÖ $repo_name: Limpio"
        return 0
    fi

    echo "  üì¶ $repo_name: $total_clean sin cambios, $total_changes con cambios"

    # Procesar ramas sin cambios (seguras)
    for entry in "${clean_branches[@]}"; do
        local branch="${entry%%|*}"
        local info="${entry#*|}"
        if $DRY_RUN; then
            info "      [dry-run] $branch$info"
        else
            if git branch -d "$branch" &>/dev/null; then
                success "      ‚úÖ $branch$info"
            else
                error "      ‚ùå Error: $branch"
            fi
        fi
    done

    # Procesar ramas con cambios (solo con --force)
    for entry in "${with_changes[@]}"; do
        local branch="${entry%%|*}"
        local rest="${entry#*|}"
        local commits="${rest%%|*}"
        local info="${rest#*|}"
        if $FORCE; then
            if $DRY_RUN; then
                warning "      [dry-run] $branch (+$commits commits)$info"
            else
                if git branch -D "$branch" &>/dev/null; then
                    warning "      ‚ö†Ô∏è  $branch (+$commits commits)$info"
                else
                    error "      ‚ùå Error: $branch"
                fi
            fi
        else
            warning "      ‚è≠Ô∏è  $branch (+$commits commits)$info"
        fi
    done
}

# Header
echo ""
if $DRY_RUN; then
    info "üîç Modo dry-run: mostrando qu√© se borrar√≠a"
fi
if $FORCE; then
    warning "‚ö†Ô∏è  Modo force: se borrar√°n incluso ramas no mergeadas"
fi
echo ""
echo "Limpiando ramas hu√©rfanas en ${#REPOS[@]} repo(s)..."
echo ""

# Procesar cada repo
for repo in "${REPOS[@]}"; do
    repo_path="$WORKSPACE_ROOT/$repo"
    prune_repo "$repo_path" "$repo"
done

echo ""
if $DRY_RUN; then
    info "üí° Ejecuta sin --dry-run para aplicar los cambios"
fi
