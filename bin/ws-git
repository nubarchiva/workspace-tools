#!/bin/bash
# Ejecuta comandos Git en todos los repos de un workspace

# Inicializacion centralizada
source "$(dirname "${BASH_SOURCE[0]:-$0}")/ws-init.sh"

# Determinar workspace y argumentos
# Prioridad: 1) Workspace expl√≠cito si $1 coincide con uno existente
#            2) Auto-detecci√≥n si estamos dentro de un workspace
#            3) Modo tradicional (primer arg es workspace)
WORKSPACE_PATTERN=""
GIT_ARGS=""

if [ -n "$1" ]; then
    # Verificar si primer argumento corresponde a un workspace existente
    first_arg_lower=$(echo "$1" | tr '[:upper:]' '[:lower:]')
    is_workspace=false

    if [ -d "$WORKSPACES_DIR" ]; then
        for ws_dir in "$WORKSPACES_DIR"/*; do
            if [ -d "$ws_dir" ]; then
                ws_name=$(basename "$ws_dir")
                ws_name_lower=$(echo "$ws_name" | tr '[:upper:]' '[:lower:]')
                if [[ "$ws_name_lower" == *"$first_arg_lower"* ]]; then
                    is_workspace=true
                    break
                fi
            fi
        done
    fi

    if [ "$is_workspace" = true ]; then
        # Primer argumento coincide con workspace ‚Üí modo expl√≠cito
        WORKSPACE_PATTERN="$1"
        shift
        GIT_ARGS="$@"
    else
        # Primer argumento NO es workspace ‚Üí intentar auto-detecci√≥n
        DETECTED_WORKSPACE=$(detect_current_workspace 2>/dev/null || true)
        if [ -n "$DETECTED_WORKSPACE" ]; then
            # Auto-detectado, todos los args son para Git
            WORKSPACE_PATTERN="$DETECTED_WORKSPACE"
            GIT_ARGS="$@"
        else
            # No auto-detectado, asumir modo tradicional
            WORKSPACE_PATTERN="$1"
            shift
            GIT_ARGS="$@"
        fi
    fi
else
    # Sin argumentos, intentar auto-detecci√≥n
    DETECTED_WORKSPACE=$(detect_current_workspace 2>/dev/null || true)
    if [ -n "$DETECTED_WORKSPACE" ]; then
        WORKSPACE_PATTERN="$DETECTED_WORKSPACE"
        # Si primer argumento est√° vac√≠o (ej: wgt sin args), saltarlo
        if [ "$#" -gt 0 ] && [ -z "$1" ]; then
            shift
        fi
        GIT_ARGS="$@"
    fi
fi

# Funci√≥n de ayuda
show_help() {
    echo "Uso: ws git <nombre|patr√≥n> <comando-git> [argumentos...]"
    echo ""
    echo "Ejecuta comandos Git en todos los repos de un workspace."
    echo ""
    echo "üí° Puedes usar coincidencia parcial para el nombre del workspace"
    echo ""
    echo "Ejemplos:"
    echo "  ws git nuba-8400 status"
    echo "  ws git master pull"
    echo "  ws git fac log --oneline -5"
    echo "  ws git 8089 fetch"
    echo ""
    echo "Comportamiento:"
    echo "  ‚Ä¢ Ejecuta 'git <args>' en cada repo del workspace"
    echo "  ‚Ä¢ Se detiene en el primer error"
    echo "  ‚Ä¢ Ignora directorios sin .git"
}

# Si no se especific√≥ workspace, intentar detectar autom√°ticamente
if [ -z "$WORKSPACE_PATTERN" ]; then
    WORKSPACE_PATTERN=$(detect_current_workspace)
    if [ -z "$WORKSPACE_PATTERN" ]; then
        error "‚ùå Error: no se especific√≥ workspace y no se pudo detectar autom√°ticamente"
        echo ""
        info "üí° Ejecuta este comando desde dentro de un workspace o especifica el nombre:"
        echo "   ws git <workspace> <comando-git>"
        echo ""
        show_help
        exit 1
    fi
    info "üîç Workspace detectado: $WORKSPACE_PATTERN"
fi

if [ -z "$GIT_ARGS" ]; then
    error "‚ùå Error: debes especificar un comando para Git"
    echo ""
    show_help
    exit 1
fi

# Buscar workspace que coincida con el patr√≥n
WORKSPACE_NAME=$(find_matching_workspace "$WORKSPACE_PATTERN" "$WORKSPACES_DIR")
if [ $? -ne 0 ]; then
    exit 1
fi

# Determinar directorio del workspace
WORKSPACE_DIR=$WORKSPACES_DIR/$WORKSPACE_NAME
BRANCH_NAME=$(get_branch_name "$WORKSPACE_NAME")

if [ ! -d "$WORKSPACE_DIR" ]; then
    error "‚ùå Workspace no existe: $WORKSPACE_NAME"
    exit 1
fi

print_header "Ejecutando Git en workspace"
echo ""
echo "Workspace: ${COLOR_CYAN}$WORKSPACE_NAME${COLOR_RESET}"
echo "Branch:    ${COLOR_CYAN}$BRANCH_NAME${COLOR_RESET}"
echo "Comando:   ${COLOR_BOLD}git $GIT_ARGS${COLOR_RESET}"
echo ""

# Encontrar todos los repos en el workspace
repos=$(find_repos_in_workspace "$WORKSPACE_DIR")

if [ -z "$repos" ] || [ "$repos" = "" ]; then
    error "‚ùå No hay repos en este workspace"
    exit 1
fi

# Ejecutar Git en cada repo
echo "$repos" | while read -r repo_rel_path; do
    if [ -n "$repo_rel_path" ]; then
        repo_path="$WORKSPACE_DIR/$repo_rel_path"

        if [ -d "$repo_path/.git" ] || [ -f "$repo_path/.git" ]; then
            print_separator_with_title "${COLOR_CYAN}$repo_rel_path${COLOR_RESET}"
            echo ""

            # Cambiar al directorio del repo y ejecutar Git
            cd "$repo_path"

            # Detectar si es "push" sin upstream y a√±adir -u autom√°ticamente
            ACTUAL_GIT_ARGS="$GIT_ARGS"
            if [ "$GIT_ARGS" = "push" ]; then
                # Verificar si hay upstream configurado
                if ! git rev-parse --abbrev-ref @{u} >/dev/null 2>&1; then
                    current_branch=$(git branch --show-current)
                    info "   üì§ Sin upstream, ejecutando: git push -u origin $current_branch"
                    ACTUAL_GIT_ARGS="push -u origin $current_branch"
                fi
            fi

            git $ACTUAL_GIT_ARGS

            # Verificar el resultado
            exit_code=$?
            if [ $exit_code -ne 0 ]; then
                echo ""
                error "‚ùå Error en $repo_rel_path (exit code: $exit_code)"
                error "   Deteniendo ejecuci√≥n"
                exit $exit_code
            fi

            echo ""
        fi
    fi
done

# Capturar el exit code del while loop
exit_code=$?

if [ $exit_code -ne 0 ]; then
    exit $exit_code
fi

success "‚úÖ Git ejecutado correctamente en todos los repos"
