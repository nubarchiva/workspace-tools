#!/bin/bash
# Renombra un workspace (directorio + branches + worktrees)

# Inicializacion centralizada
source "$(dirname "${BASH_SOURCE[0]:-$0}")/ws-init.sh"

REPOS_DIR=$WORKSPACE_ROOT/repos

OLD_NAME=$1
NEW_NAME=$2

# FunciÃ³n de ayuda
show_help() {
    echo "Uso: ws rename <nombre-actual> <nombre-nuevo>"
    echo ""
    echo "Renombra un workspace (directorio, branches locales, referencias de worktrees)."
    echo ""
    echo "Verificaciones de seguridad:"
    echo "  â€¢ BLOQUEA si hay cambios sin commitear"
    echo "  â€¢ ADVIERTE si hay commits sin pushear"
    echo "  â€¢ ADVIERTE si hay branches con tracking remoto"
    echo ""
    echo "Ejemplos:"
    echo "  ws rename feature-123 feature-456"
    echo "  ws rename old-name new-name"
    echo ""
    echo "IMPORTANTE:"
    echo "  â€¢ Tus commits locales NO se perderÃ¡n"
    echo "  â€¢ NecesitarÃ¡s reconfigurar branches remotas despuÃ©s"
    echo "  â€¢ Si trabajas en equipo, coordina el cambio"
}

# Validar argumentos
if [ -z "$OLD_NAME" ] || [ -z "$NEW_NAME" ]; then
    error "âŒ Error: debes especificar nombre actual y nombre nuevo"
    echo ""
    show_help
    exit 1
fi

# Verificar que el workspace actual existe
OLD_DIR="$WORKSPACES_DIR/$OLD_NAME"
if [ ! -d "$OLD_DIR" ]; then
    error "âŒ Error: workspace '$OLD_NAME' no existe"
    echo ""
    echo "Workspaces disponibles:"
    if [ -d "$WORKSPACES_DIR" ]; then
        for ws_dir in "$WORKSPACES_DIR"/*; do
            if [ -d "$ws_dir" ]; then
                ws_name=$(basename "$ws_dir")
                echo "  â€¢ ${COLOR_CYAN}$ws_name${COLOR_RESET}"
            fi
        done
    fi
    exit 1
fi

# Verificar que el nuevo nombre no existe
NEW_DIR="$WORKSPACES_DIR/$NEW_NAME"
if [ -d "$NEW_DIR" ]; then
    error "âŒ Error: workspace '$NEW_NAME' ya existe"
    exit 1
fi

# Encontrar repos en el workspace
repos=$(find_repos_in_workspace "$OLD_DIR")
if [ -z "$repos" ]; then
    warning "âš ï¸  Workspace '$OLD_NAME' no tiene repos"
    echo ""
    echo "Â¿Renombrar workspace vacÃ­o de todas formas? [y/N]: "
    read -r response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        echo "Renombrado cancelado"
        exit 0
    fi
    # Continuar con renombrado simple
    mv "$OLD_DIR" "$NEW_DIR"
    success "âœ… Workspace renombrado: $OLD_NAME â†’ $NEW_NAME"
    exit 0
fi

# Contadores para verificaciones
has_uncommitted=0
has_unpushed=0
has_upstream=0
uncommitted_repos=()
unpushed_repos=()
upstream_repos=()

echo ""
info "ğŸ” Verificando estado de repos..."
echo ""

# Verificar cada repo
echo "$repos" | while IFS= read -r repo_rel_path; do
    if [ -z "$repo_rel_path" ]; then
        continue
    fi

    repo_path="$OLD_DIR/$repo_rel_path"
    cd "$repo_path"

    # 1. Verificar cambios sin commitear
    if [ -n "$(git status --porcelain)" ]; then
        uncommitted_repos+=("$repo_rel_path")
        has_uncommitted=1
    fi

    # 2. Verificar commits sin pushear
    current_branch=$(git branch --show-current)
    if [ -n "$current_branch" ]; then
        # Verificar si tiene upstream
        if git rev-parse --abbrev-ref @{u} >/dev/null 2>&1; then
            upstream_repos+=("$repo_rel_path")
            has_upstream=1

            # Contar commits sin pushear
            unpushed_count=$(git rev-list @{u}..HEAD 2>/dev/null | wc -l | tr -d ' ')
            if [ "$unpushed_count" -gt 0 ]; then
                unpushed_repos+=("$repo_rel_path:$unpushed_count")
                has_unpushed=1
            fi
        else
            # Sin upstream, contar commits totales en la branch
            commit_count=$(git rev-list HEAD 2>/dev/null | wc -l | tr -d ' ')
            if [ "$commit_count" -gt 0 ]; then
                unpushed_repos+=("$repo_rel_path:$commit_count")
                has_unpushed=1
            fi
        fi
    fi
done

# Capturar los resultados del subshell
has_uncommitted=0
has_unpushed=0
has_upstream=0
declare -a uncommitted_repos
declare -a unpushed_repos
declare -a upstream_repos

echo "$repos" | while IFS= read -r repo_rel_path; do
    if [ -z "$repo_rel_path" ]; then
        continue
    fi

    repo_path="$OLD_DIR/$repo_rel_path"
    cd "$repo_path"

    # 1. Verificar cambios sin commitear
    status_output=$(git status --porcelain)
    if [ -n "$status_output" ]; then
        echo "UNCOMMITTED:$repo_rel_path:$(echo "$status_output" | wc -l | tr -d ' ')"
    fi

    # 2. Verificar commits sin pushear y upstream
    current_branch=$(git branch --show-current)
    if [ -n "$current_branch" ]; then
        if git rev-parse --abbrev-ref @{u} >/dev/null 2>&1; then
            upstream_branch=$(git rev-parse --abbrev-ref @{u})
            echo "UPSTREAM:$repo_rel_path:$upstream_branch"

            unpushed_count=$(git rev-list @{u}..HEAD 2>/dev/null | wc -l | tr -d ' ')
            if [ "$unpushed_count" -gt 0 ]; then
                echo "UNPUSHED:$repo_rel_path:$unpushed_count"
            fi
        else
            commit_count=$(git rev-list HEAD 2>/dev/null | wc -l | tr -d ' ')
            if [ "$commit_count" -gt 0 ]; then
                echo "UNPUSHED:$repo_rel_path:$commit_count"
            fi
        fi
    fi
done > /tmp/ws-rename-check.$$

# Procesar resultados
while IFS=: read -r type repo_path data; do
    case "$type" in
        UNCOMMITTED)
            has_uncommitted=1
            uncommitted_repos+=("$repo_path ($data archivos)")
            ;;
        UPSTREAM)
            has_upstream=1
            upstream_repos+=("$repo_path â†’ $data")
            ;;
        UNPUSHED)
            has_unpushed=1
            unpushed_repos+=("$repo_path ($data commits)")
            ;;
    esac
done < /tmp/ws-rename-check.$$
rm -f /tmp/ws-rename-check.$$

# VERIFICACIÃ“N 1: Cambios sin commitear (BLOQUEANTE)
if [ $has_uncommitted -eq 1 ]; then
    echo ""
    error "âŒ ERROR: No se puede renombrar el workspace"
    echo ""
    echo "Hay cambios sin commitear en:"
    for repo_info in "${uncommitted_repos[@]}"; do
        echo "  â€¢ ${COLOR_YELLOW}$repo_info${COLOR_RESET}"
    done
    echo ""
    warning "âš ï¸  CONSECUENCIA: Renombrar romperÃ­a las referencias de Git."
    echo "   Aunque NO perderÃ­as los cambios, quedarÃ­an en un estado inconsistente."
    echo ""
    success "âœ… SOLUCIÃ“N antes de renombrar:"
    echo ""
    echo "   ${COLOR_BOLD}OpciÃ³n 1 - Commitear cambios:${COLOR_RESET}"
    echo "     cd $OLD_DIR/<repo>"
    echo "     git add ."
    echo "     git commit -m \"tu mensaje\""
    echo ""
    echo "   ${COLOR_BOLD}OpciÃ³n 2 - Guardar temporalmente:${COLOR_RESET}"
    echo "     cd $OLD_DIR/<repo>"
    echo "     git stash save \"cambios antes de renombrar workspace\""
    echo ""
    error "Renombrado CANCELADO por seguridad."
    exit 1
fi

success "âœ… No hay cambios sin commitear"

# VERIFICACIÃ“N 2: Commits sin pushear (WARNING)
if [ $has_unpushed -eq 1 ]; then
    echo ""
    warning "âš ï¸  ADVERTENCIA: Commits locales sin pushear"
    echo ""
    for repo_info in "${unpushed_repos[@]}"; do
        echo "  â€¢ ${COLOR_CYAN}$repo_info${COLOR_RESET}"
    done
    echo ""
    echo "${COLOR_BOLD}ğŸ“‹ QUÃ‰ SIGNIFICA ESTO:${COLOR_RESET}"
    echo "   ${COLOR_GREEN}âœ… Tus commits estÃ¡n SEGUROS (guardados localmente)${COLOR_RESET}"
    echo "   ${COLOR_GREEN}âœ… NO se perderÃ¡n con el renombrado${COLOR_RESET}"
    echo "   ${COLOR_GREEN}âœ… El renombrado funcionarÃ¡ correctamente${COLOR_RESET}"
    echo ""
    echo "${COLOR_YELLOW}âš ï¸  PERO DESPUÃ‰S del renombrado:${COLOR_RESET}"
    echo "   - DeberÃ¡s hacer 'git push' manualmente en cada repo"
    echo "   - Si la branch remota se llama \"feature/$OLD_NAME\", tendrÃ¡s que decidir:"
    echo "     * Crear nueva branch remota: ${COLOR_CYAN}git push -u origin feature/$NEW_NAME${COLOR_RESET}"
    echo "     * Borrar la antigua: ${COLOR_CYAN}git push origin --delete feature/$OLD_NAME${COLOR_RESET}"
    echo ""
    echo "${COLOR_BOLD}ğŸ’¡ RECOMENDACIÃ“N:${COLOR_RESET}"
    echo "   Si trabajas en equipo, mejor pushea ANTES de renombrar."
    echo "   Esto evita confusiÃ³n con tus compaÃ±eros."
    echo ""
    echo -n "Â¿Entiendes las consecuencias y quieres continuar? [y/N]: "
    read -r response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        echo "Renombrado cancelado"
        exit 0
    fi
fi

# VERIFICACIÃ“N 3: Branches con upstream (WARNING)
if [ $has_upstream -eq 1 ]; then
    echo ""
    warning "âš ï¸  ADVERTENCIA: Branches pusheadas al remoto"
    echo ""
    for repo_info in "${upstream_repos[@]}"; do
        echo "  â€¢ ${COLOR_CYAN}$repo_info${COLOR_RESET}"
    done
    echo ""
    echo "${COLOR_BOLD}ğŸ“‹ QUÃ‰ VA A PASAR:${COLOR_RESET}"
    echo "   1. Branch LOCAL se renombrarÃ¡: ${COLOR_CYAN}feature/$NEW_NAME${COLOR_RESET} âœ…"
    echo "   2. Branch REMOTA seguirÃ¡: ${COLOR_YELLOW}origin/feature/$OLD_NAME${COLOR_RESET} âŒ"
    echo "   3. Tracking se romperÃ¡: Git no sabrÃ¡ dÃ³nde pushear"
    echo ""
    echo "${COLOR_YELLOW}âš ï¸  CONSECUENCIAS:${COLOR_RESET}"
    echo "   - 'git push' darÃ¡ error hasta que reconfigures el tracking"
    echo "   - Otros desarrolladores seguirÃ¡n viendo \"feature/$OLD_NAME\" en GitHub"
    echo "   - Pull requests apuntarÃ¡n a la branch antigua"
    echo ""
    echo "${COLOR_BOLD}âœ… SOLUCIÃ“N (despuÃ©s del renombrado):${COLOR_RESET}"
    echo ""
    echo "   Para cada repo, ejecuta:"
    echo ""
    echo "   ${COLOR_CYAN}# Crear nueva branch remota${COLOR_RESET}"
    echo "   git push -u origin feature/$NEW_NAME"
    echo ""
    echo "   ${COLOR_CYAN}# Borrar branch antigua (CUIDADO si trabajas en equipo)${COLOR_RESET}"
    echo "   git push origin --delete feature/$OLD_NAME"
    echo ""
    echo "   O mantener ambas branches (puedes decidir despuÃ©s)"
    echo ""
    echo "${COLOR_BOLD}ğŸ’¡ SI TRABAJAS EN EQUIPO:${COLOR_RESET}"
    echo "   Coordina con tu equipo ANTES de renombrar."
    echo "   Ellos deberÃ¡n actualizar sus referencias."
    echo ""
    echo -n "Â¿Entiendes las consecuencias? Escribe 'CONTINUAR': "
    read -r response
    if [ "$response" != "CONTINUAR" ]; then
        echo "Renombrado cancelado"
        exit 0
    fi
fi

# Contar repos
repo_count=$(echo "$repos" | grep -c .)

# RESUMEN FINAL
echo ""
echo "${COLOR_BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${COLOR_RESET}"
echo "${COLOR_BOLD}              RESUMEN DE RENOMBRADO${COLOR_RESET}"
echo "${COLOR_BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${COLOR_RESET}"
echo ""
echo "Workspace: ${COLOR_CYAN}$OLD_NAME${COLOR_RESET} â†’ ${COLOR_GREEN}$NEW_NAME${COLOR_RESET}"
echo ""
echo "Directorio:"
echo "  $OLD_DIR â†’"
echo "  $NEW_DIR"
echo ""
echo "Repos ($repo_count):"
echo "$repos" | while IFS= read -r repo_rel_path; do
    if [ -n "$repo_rel_path" ]; then
        cd "$OLD_DIR/$repo_rel_path"
        current_branch=$(git branch --show-current)
        if [[ "$current_branch" == "feature/$OLD_NAME" ]] || [[ "$current_branch" == "$OLD_NAME" ]]; then
            new_branch="feature/$NEW_NAME"
            echo "  â€¢ ${COLOR_CYAN}$repo_rel_path${COLOR_RESET} (branch: $current_branch â†’ $new_branch)"
        else
            echo "  â€¢ ${COLOR_CYAN}$repo_rel_path${COLOR_RESET} (branch: $current_branch - sin cambios)"
        fi
    fi
done
echo ""
echo "Estado:"
if [ $has_uncommitted -eq 0 ]; then
    echo "  ${COLOR_GREEN}âœ… Sin cambios pendientes${COLOR_RESET}"
else
    echo "  ${COLOR_YELLOW}âš ï¸  Hay cambios sin commitear${COLOR_RESET}"
fi
if [ $has_unpushed -eq 1 ]; then
    echo "  ${COLOR_YELLOW}âš ï¸  Hay commits sin pushear (no se perderÃ¡n)${COLOR_RESET}"
fi
if [ $has_upstream -eq 1 ]; then
    echo "  ${COLOR_YELLOW}âš ï¸  Hay branches remotas (requerirÃ¡n reconfiguraciÃ³n)${COLOR_RESET}"
fi
echo ""
echo "${COLOR_BOLD}ACCIONES QUE SE EJECUTARÃN:${COLOR_RESET}"
echo "  1. Renombrar directorio: mv $OLD_DIR $NEW_DIR"
echo "  2. Reparar referencias: git worktree repair (en cada repo)"
echo "  3. Renombrar branches: git branch -m (solo si siguen patrÃ³n del workspace)"
echo ""
if [ $has_unpushed -eq 1 ] || [ $has_upstream -eq 1 ]; then
    echo "${COLOR_BOLD}TAREAS PENDIENTES DESPUÃ‰S:${COLOR_RESET}"
    if [ $has_unpushed -eq 1 ]; then
        echo "  â€¢ Pushear commits locales"
    fi
    if [ $has_upstream -eq 1 ]; then
        echo "  â€¢ Reconfigurar tracking de branches remotas"
        echo "  â€¢ Coordinar con equipo si corresponde"
    fi
    echo ""
fi
echo "${COLOR_YELLOW}âš ï¸  IMPORTANTE: Esta operaciÃ³n NO se puede deshacer automÃ¡ticamente.${COLOR_RESET}"
echo ""
echo "Para confirmar, escribe exactamente: ${COLOR_BOLD}RENOMBRAR${COLOR_RESET}"
echo -n "Para cancelar, presiona Enter o escribe cualquier otra cosa: "
read -r confirmation

if [ "$confirmation" != "RENOMBRAR" ]; then
    echo ""
    echo "Renombrado cancelado"
    exit 0
fi

# EJECUTAR RENOMBRADO
echo ""
info "ğŸ”„ Renombrando workspace..."
echo ""

# 1. Renombrar directorio
echo "1ï¸âƒ£  Renombrando directorio..."
mv "$OLD_DIR" "$NEW_DIR"
if [ $? -ne 0 ]; then
    error "âŒ Error al renombrar directorio"
    exit 1
fi
success "   âœ… Directorio renombrado"

# 2. Reparar worktrees
echo ""
echo "2ï¸âƒ£  Reparando referencias de worktrees..."
echo "$repos" | while IFS= read -r repo_rel_path; do
    if [ -z "$repo_rel_path" ]; then
        continue
    fi

    # Determinar repo principal
    repo_name=$(basename "$repo_rel_path")
    repo_main="$REPOS_DIR/$repo_name"

    if [ -d "$repo_main/.git" ]; then
        cd "$repo_main"
        git worktree repair >/dev/null 2>&1
        if [ $? -eq 0 ]; then
            success "   âœ… $repo_rel_path"
        else
            warning "   âš ï¸  $repo_rel_path (no se pudo reparar)"
        fi
    fi
done

# 3. Renombrar branches
echo ""
echo "3ï¸âƒ£  Renombrando branches locales..."
echo "$repos" | while IFS= read -r repo_rel_path; do
    if [ -z "$repo_rel_path" ]; then
        continue
    fi

    repo_path="$NEW_DIR/$repo_rel_path"
    cd "$repo_path"

    current_branch=$(git branch --show-current)

    # Solo renombrar si sigue el patrÃ³n del workspace
    if [[ "$current_branch" == "feature/$OLD_NAME" ]]; then
        new_branch="feature/$NEW_NAME"
        git branch -m "$new_branch" >/dev/null 2>&1
        if [ $? -eq 0 ]; then
            success "   âœ… $repo_rel_path: $current_branch â†’ $new_branch"
        else
            warning "   âš ï¸  $repo_rel_path: no se pudo renombrar branch"
        fi
    elif [[ "$current_branch" == "$OLD_NAME" ]]; then
        new_branch="$NEW_NAME"
        git branch -m "$new_branch" >/dev/null 2>&1
        if [ $? -eq 0 ]; then
            success "   âœ… $repo_rel_path: $current_branch â†’ $new_branch"
        else
            warning "   âš ï¸  $repo_rel_path: no se pudo renombrar branch"
        fi
    else
        info "   â„¹ï¸  $repo_rel_path: branch '$current_branch' sin cambios"
    fi
done

echo ""
echo "${COLOR_BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${COLOR_RESET}"
success "âœ… Workspace renombrado exitosamente: $OLD_NAME â†’ $NEW_NAME"
echo "${COLOR_BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${COLOR_RESET}"

# Recordatorios finales
if [ $has_unpushed -eq 1 ] || [ $has_upstream -eq 1 ]; then
    echo ""
    warning "ğŸ“‹ RECORDATORIOS:"
    if [ $has_unpushed -eq 1 ]; then
        echo ""
        echo "   ${COLOR_BOLD}1. Pushear commits locales:${COLOR_RESET}"
        echo "      cd $NEW_DIR/<repo>"
        echo "      git push"
    fi
    if [ $has_upstream -eq 1 ]; then
        echo ""
        echo "   ${COLOR_BOLD}2. Reconfigurar branches remotas:${COLOR_RESET}"
        echo "      cd $NEW_DIR/<repo>"
        echo "      git push -u origin feature/$NEW_NAME"
        echo "      git push origin --delete feature/$OLD_NAME"
    fi
fi

echo ""
info "ğŸ“ Nueva ubicaciÃ³n: ${COLOR_CYAN}$NEW_DIR${COLOR_RESET}"
echo ""
