#!/bin/bash
# Renombra un workspace (directorio + branches + worktrees)

# Inicializacion centralizada
source "$(dirname "${BASH_SOURCE[0]:-$0}")/ws-init.sh"

# =============================================================================
# Variables globales
# =============================================================================

# NOTA: Los repos est√°n directamente en WORKSPACE_ROOT, no en un subdirectorio /repos
REPOS_DIR="$WORKSPACE_ROOT"
OLD_NAME="$1"
NEW_NAME="$2"

# Arrays para resultados de verificaci√≥n
declare -a uncommitted_repos
declare -a unpushed_repos
declare -a upstream_repos
has_uncommitted=0
has_unpushed=0
has_upstream=0

# =============================================================================
# Funciones de ayuda y validaci√≥n
# =============================================================================

show_help() {
    echo "Uso: ws rename <nombre-actual> <nombre-nuevo>"
    echo ""
    echo "Renombra un workspace (directorio, branches locales, referencias de worktrees)."
    echo ""
    echo "Verificaciones de seguridad:"
    echo "  ‚Ä¢ BLOQUEA si hay cambios sin commitear"
    echo "  ‚Ä¢ ADVIERTE si hay commits sin pushear"
    echo "  ‚Ä¢ ADVIERTE si hay branches con tracking remoto"
    echo ""
    echo "Ejemplos:"
    echo "  ws rename feature-123 feature-456"
    echo "  ws rename old-name new-name"
    echo ""
    echo "IMPORTANTE:"
    echo "  ‚Ä¢ Tus commits locales NO se perder√°n"
    echo "  ‚Ä¢ Necesitar√°s reconfigurar branches remotas despu√©s"
    echo "  ‚Ä¢ Si trabajas en equipo, coordina el cambio"
}

validate_arguments() {
    if [ -z "$OLD_NAME" ] || [ -z "$NEW_NAME" ]; then
        error "‚ùå Error: debes especificar nombre actual y nombre nuevo"
        echo ""
        show_help
        exit 1
    fi
}

validate_workspaces() {
    # Verificar que el workspace actual existe
    OLD_DIR="$WORKSPACES_DIR/$OLD_NAME"
    if [ ! -d "$OLD_DIR" ]; then
        error "‚ùå Error: workspace '$OLD_NAME' no existe"
        echo ""
        echo "Workspaces disponibles:"
        if [ -d "$WORKSPACES_DIR" ]; then
            for ws_dir in "$WORKSPACES_DIR"/*; do
                if [ -d "$ws_dir" ]; then
                    echo "  ‚Ä¢ ${COLOR_CYAN}$(basename "$ws_dir")${COLOR_RESET}"
                fi
            done
        fi
        exit 1
    fi

    # Verificar que el nuevo nombre no existe
    NEW_DIR="$WORKSPACES_DIR/$NEW_NAME"
    if [ -d "$NEW_DIR" ]; then
        die "Error: workspace '$NEW_NAME' ya existe"
    fi
}

# =============================================================================
# Funciones de verificaci√≥n de estado
# =============================================================================

# Verifica el estado de todos los repos y llena los arrays globales
check_repos_status() {
    local workspace_dir="$1"
    local repos="$2"

    # Usar archivo temporal para capturar resultados del subshell
    local temp_file
    temp_file=$(mktemp)
    trap "rm -f $temp_file" RETURN

    echo "$repos" | while IFS= read -r repo_rel_path; do
        [ -z "$repo_rel_path" ] && continue

        local repo_path="$workspace_dir/$repo_rel_path"
        [ ! -d "$repo_path" ] && continue

        # Usar git_repo_status del m√≥dulo ws-git-utils.sh
        local status
        status=$(git_repo_status "$repo_path")

        # Parsear resultado: "uncommitted:unpushed:has_upstream:branch:upstream"
        IFS=':' read -r uncommitted unpushed repo_has_upstream branch upstream_branch <<< "$status"

        # Cambios sin commitear
        if [ "$uncommitted" -gt 0 ]; then
            echo "UNCOMMITTED:$repo_rel_path:$uncommitted"
        fi

        # Commits sin pushear
        if [ "$unpushed" -gt 0 ]; then
            echo "UNPUSHED:$repo_rel_path:$unpushed"
        fi

        # Tiene upstream
        if [ "$repo_has_upstream" -eq 1 ]; then
            echo "UPSTREAM:$repo_rel_path:$upstream_branch"
        fi
    done > "$temp_file"

    # Procesar resultados
    while IFS=: read -r type repo_path data; do
        case "$type" in
            UNCOMMITTED)
                has_uncommitted=1
                uncommitted_repos+=("$repo_path ($data archivos)")
                ;;
            UPSTREAM)
                has_upstream=1
                upstream_repos+=("$repo_path ‚Üí $data")
                ;;
            UNPUSHED)
                has_unpushed=1
                unpushed_repos+=("$repo_path ($data commits)")
                ;;
        esac
    done < "$temp_file"
}

# =============================================================================
# Funciones de verificaci√≥n y advertencia
# =============================================================================

block_if_uncommitted() {
    [ $has_uncommitted -eq 0 ] && return 0

    echo ""
    error "‚ùå ERROR: No se puede renombrar el workspace"
    echo ""
    echo "Hay cambios sin commitear en:"
    for repo_info in "${uncommitted_repos[@]}"; do
        echo "  ‚Ä¢ ${COLOR_YELLOW}$repo_info${COLOR_RESET}"
    done
    echo ""
    warning "‚ö†Ô∏è  CONSECUENCIA: Renombrar romper√≠a las referencias de Git."
    echo "   Aunque NO perder√≠as los cambios, quedar√≠an en un estado inconsistente."
    echo ""
    success "‚úÖ SOLUCI√ìN antes de renombrar:"
    echo ""
    echo "   ${COLOR_BOLD}Opci√≥n 1 - Commitear cambios:${COLOR_RESET}"
    echo "     cd $OLD_DIR/<repo>"
    echo "     git add ."
    echo "     git commit -m \"tu mensaje\""
    echo ""
    echo "   ${COLOR_BOLD}Opci√≥n 2 - Guardar temporalmente:${COLOR_RESET}"
    echo "     cd $OLD_DIR/<repo>"
    echo "     git stash save \"cambios antes de renombrar workspace\""
    echo ""
    error "Renombrado CANCELADO por seguridad."
    exit 1
}

warn_unpushed_commits() {
    [ $has_unpushed -eq 0 ] && return 0

    echo ""
    warning "‚ö†Ô∏è  ADVERTENCIA: Commits locales sin pushear"
    echo ""
    for repo_info in "${unpushed_repos[@]}"; do
        echo "  ‚Ä¢ ${COLOR_CYAN}$repo_info${COLOR_RESET}"
    done
    echo ""
    echo "${COLOR_BOLD}üìã QU√â SIGNIFICA ESTO:${COLOR_RESET}"
    echo "   ${COLOR_GREEN}‚úÖ Tus commits est√°n SEGUROS (guardados localmente)${COLOR_RESET}"
    echo "   ${COLOR_GREEN}‚úÖ NO se perder√°n con el renombrado${COLOR_RESET}"
    echo "   ${COLOR_GREEN}‚úÖ El renombrado funcionar√° correctamente${COLOR_RESET}"
    echo ""
    echo "${COLOR_YELLOW}‚ö†Ô∏è  PERO DESPU√âS del renombrado:${COLOR_RESET}"
    echo "   - Deber√°s hacer 'git push' manualmente en cada repo"
    echo "   - Si la branch remota se llama \"feature/$OLD_NAME\", tendr√°s que decidir:"
    echo "     * Crear nueva branch remota: ${COLOR_CYAN}git push -u origin feature/$NEW_NAME${COLOR_RESET}"
    echo "     * Borrar la antigua: ${COLOR_CYAN}git push origin --delete feature/$OLD_NAME${COLOR_RESET}"
    echo ""
    echo "${COLOR_BOLD}üí° RECOMENDACI√ìN:${COLOR_RESET}"
    echo "   Si trabajas en equipo, mejor pushea ANTES de renombrar."
    echo ""
    echo -n "¬øEntiendes las consecuencias y quieres continuar? [y/N]: "
    read -r response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        echo "Renombrado cancelado"
        exit 0
    fi
}

warn_upstream_branches() {
    [ $has_upstream -eq 0 ] && return 0

    echo ""
    warning "‚ö†Ô∏è  ADVERTENCIA: Branches pusheadas al remoto"
    echo ""
    for repo_info in "${upstream_repos[@]}"; do
        echo "  ‚Ä¢ ${COLOR_CYAN}$repo_info${COLOR_RESET}"
    done
    echo ""
    echo "${COLOR_BOLD}üìã QU√â VA A PASAR:${COLOR_RESET}"
    echo "   1. Branch LOCAL se renombrar√°: ${COLOR_CYAN}feature/$NEW_NAME${COLOR_RESET} ‚úÖ"
    echo "   2. Branch REMOTA seguir√°: ${COLOR_YELLOW}origin/feature/$OLD_NAME${COLOR_RESET} ‚ùå"
    echo "   3. Tracking se romper√°: Git no sabr√° d√≥nde pushear"
    echo ""
    echo "${COLOR_YELLOW}‚ö†Ô∏è  CONSECUENCIAS:${COLOR_RESET}"
    echo "   - 'git push' dar√° error hasta que reconfigures el tracking"
    echo "   - Otros desarrolladores seguir√°n viendo \"feature/$OLD_NAME\" en GitHub"
    echo ""
    echo "${COLOR_BOLD}‚úÖ SOLUCI√ìN (despu√©s del renombrado):${COLOR_RESET}"
    echo "   ${COLOR_CYAN}git push -u origin feature/$NEW_NAME${COLOR_RESET}"
    echo "   ${COLOR_CYAN}git push origin --delete feature/$OLD_NAME${COLOR_RESET}"
    echo ""
    echo -n "¬øEntiendes las consecuencias? Escribe 'CONTINUAR': "
    read -r response
    if [ "$response" != "CONTINUAR" ]; then
        echo "Renombrado cancelado"
        exit 0
    fi
}

# =============================================================================
# Funciones de resumen y confirmaci√≥n
# =============================================================================

show_rename_summary() {
    local repos="$1"
    local repo_count
    repo_count=$(echo "$repos" | grep -c .)

    echo ""
    print_header "RESUMEN DE RENOMBRADO"
    echo ""
    echo "Workspace: ${COLOR_CYAN}$OLD_NAME${COLOR_RESET} ‚Üí ${COLOR_GREEN}$NEW_NAME${COLOR_RESET}"
    echo ""
    echo "Directorio:"
    echo "  $OLD_DIR ‚Üí $NEW_DIR"
    echo ""
    echo "Repos ($repo_count):"
    echo "$repos" | while IFS= read -r repo_rel_path; do
        [ -z "$repo_rel_path" ] && continue
        local current_branch
        current_branch=$(git_get_current_branch "$OLD_DIR/$repo_rel_path")
        if [[ "$current_branch" == "feature/$OLD_NAME" ]] || [[ "$current_branch" == "$OLD_NAME" ]]; then
            echo "  ‚Ä¢ ${COLOR_CYAN}$repo_rel_path${COLOR_RESET} (branch: $current_branch ‚Üí feature/$NEW_NAME)"
        else
            echo "  ‚Ä¢ ${COLOR_CYAN}$repo_rel_path${COLOR_RESET} (branch: $current_branch - sin cambios)"
        fi
    done
    echo ""
    echo "Estado:"
    echo "  ${COLOR_GREEN}‚úÖ Sin cambios pendientes${COLOR_RESET}"
    [ $has_unpushed -eq 1 ] && echo "  ${COLOR_YELLOW}‚ö†Ô∏è  Hay commits sin pushear (no se perder√°n)${COLOR_RESET}"
    [ $has_upstream -eq 1 ] && echo "  ${COLOR_YELLOW}‚ö†Ô∏è  Hay branches remotas (requerir√°n reconfiguraci√≥n)${COLOR_RESET}"
    echo ""
    echo "${COLOR_BOLD}ACCIONES:${COLOR_RESET}"
    echo "  1. Renombrar directorio"
    echo "  2. Reparar referencias worktrees"
    echo "  3. Renombrar branches locales"
    echo ""
}

confirm_rename() {
    echo "${COLOR_YELLOW}‚ö†Ô∏è  Esta operaci√≥n NO se puede deshacer autom√°ticamente.${COLOR_RESET}"
    echo ""
    echo "Para confirmar, escribe exactamente: ${COLOR_BOLD}RENOMBRAR${COLOR_RESET}"
    echo -n "Para cancelar, presiona Enter: "
    read -r confirmation

    if [ "$confirmation" != "RENOMBRAR" ]; then
        echo ""
        echo "Renombrado cancelado"
        exit 0
    fi
}

# =============================================================================
# Funciones de ejecuci√≥n
# =============================================================================

rename_directory() {
    echo "1Ô∏è‚É£  Renombrando directorio..."
    if ! mv "$OLD_DIR" "$NEW_DIR"; then
        die "Error al renombrar directorio"
    fi
    success "   ‚úÖ Directorio renombrado"
}

repair_worktrees() {
    local repos="$1"

    echo ""
    echo "2Ô∏è‚É£  Reparando referencias de worktrees..."
    echo "$repos" | while IFS= read -r repo_rel_path; do
        [ -z "$repo_rel_path" ] && continue

        # Usar ruta relativa completa, no solo basename (para repos en subdirs como libs/marc4j)
        local repo_main="$REPOS_DIR/$repo_rel_path"

        if [ -d "$repo_main/.git" ]; then
            if (cd "$repo_main" && git worktree repair >/dev/null 2>&1); then
                success "   ‚úÖ $repo_rel_path"
            else
                warning "   ‚ö†Ô∏è  $repo_rel_path (no se pudo reparar)"
            fi
        fi
    done
}

rename_branches() {
    local repos="$1"

    echo ""
    echo "3Ô∏è‚É£  Renombrando branches locales..."
    echo "$repos" | while IFS= read -r repo_rel_path; do
        [ -z "$repo_rel_path" ] && continue

        local repo_path="$NEW_DIR/$repo_rel_path"
        local current_branch
        current_branch=$(git_get_current_branch "$repo_path")

        if [[ "$current_branch" == "feature/$OLD_NAME" ]]; then
            local new_branch="feature/$NEW_NAME"
            if (cd "$repo_path" && git branch -m "$new_branch" >/dev/null 2>&1); then
                success "   ‚úÖ $repo_rel_path: $current_branch ‚Üí $new_branch"
            else
                warning "   ‚ö†Ô∏è  $repo_rel_path: no se pudo renombrar branch"
            fi
        elif [[ "$current_branch" == "$OLD_NAME" ]]; then
            local new_branch="$NEW_NAME"
            if (cd "$repo_path" && git branch -m "$new_branch" >/dev/null 2>&1); then
                success "   ‚úÖ $repo_rel_path: $current_branch ‚Üí $new_branch"
            else
                warning "   ‚ö†Ô∏è  $repo_rel_path: no se pudo renombrar branch"
            fi
        else
            info "   ‚ÑπÔ∏è  $repo_rel_path: branch '$current_branch' sin cambios"
        fi
    done
}

show_post_rename_reminders() {
    [ $has_unpushed -eq 0 ] && [ $has_upstream -eq 0 ] && return

    echo ""
    warning "üìã RECORDATORIOS:"
    if [ $has_unpushed -eq 1 ]; then
        echo ""
        echo "   ${COLOR_BOLD}Pushear commits locales:${COLOR_RESET}"
        echo "      cd $NEW_DIR/<repo> && git push"
    fi
    if [ $has_upstream -eq 1 ]; then
        echo ""
        echo "   ${COLOR_BOLD}Reconfigurar branches remotas:${COLOR_RESET}"
        echo "      git push -u origin feature/$NEW_NAME"
        echo "      git push origin --delete feature/$OLD_NAME"
    fi
}

# =============================================================================
# Flujo principal
# =============================================================================

main() {
    validate_arguments
    validate_workspaces

    # Encontrar repos
    local repos
    repos=$(find_repos_in_workspace "$OLD_DIR")

    # Workspace vac√≠o: renombrado simple
    if [ -z "$repos" ]; then
        warning "‚ö†Ô∏è  Workspace '$OLD_NAME' no tiene repos"
        echo -n "¬øRenombrar workspace vac√≠o? [y/N]: "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Renombrado cancelado"
            exit 0
        fi
        mv "$OLD_DIR" "$NEW_DIR"
        success "‚úÖ Workspace renombrado: $OLD_NAME ‚Üí $NEW_NAME"
        exit 0
    fi

    # Verificar estado de repos
    echo ""
    info "üîç Verificando estado de repos..."
    check_repos_status "$OLD_DIR" "$repos"

    # Verificaciones de seguridad
    block_if_uncommitted
    success "‚úÖ No hay cambios sin commitear"
    warn_unpushed_commits
    warn_upstream_branches

    # Mostrar resumen y pedir confirmaci√≥n
    show_rename_summary "$repos"
    confirm_rename

    # Ejecutar renombrado
    echo ""
    info "üîÑ Renombrando workspace..."
    echo ""

    rename_directory
    repair_worktrees "$repos"
    rename_branches "$repos"

    # √âxito
    echo ""
    print_header "‚úÖ Workspace renombrado: $OLD_NAME ‚Üí $NEW_NAME"

    show_post_rename_reminders

    echo ""
    info "üìÅ Nueva ubicaci√≥n: ${COLOR_CYAN}$NEW_DIR${COLOR_RESET}"
    echo ""
}

main
