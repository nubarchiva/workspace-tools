#!/bin/bash
# Limpia un workspace terminado (elimina worktrees pero mantiene branches)
# Soporta repos en subdirectorios

# Inicializacion centralizada
source "$(dirname "${BASH_SOURCE[0]:-$0}")/ws-init.sh"

# Parsear argumentos
FORCE=false
WORKSPACE_PATTERN=""

for arg in "$@"; do
    case $arg in
        --force|-f)
            FORCE=true
            ;;
        *)
            WORKSPACE_PATTERN="$arg"
            ;;
    esac
done

# Funci√≥n de ayuda
show_help() {
    echo "Uso: ws clean [--force|-f] [nombre|patr√≥n]"
    echo ""
    echo "Elimina los worktrees de un workspace pero mantiene las branches."
    echo ""
    echo "Opciones:"
    echo "  --force, -f    Omitir confirmaci√≥n"
    echo ""
    echo "üí° Puedes usar coincidencia parcial para el nombre del workspace"
    echo ""
    echo "Ejemplos:"
    echo "  ws clean master"
    echo "  ws clean develop"
    echo "  ws clean nuba-8400"
    echo "  ws clean fac                     # b√∫squeda parcial"
    echo "  ws clean -f feature-123          # sin confirmaci√≥n"
    echo "  ws rm --force test               # alias con force"
    echo ""
    echo "‚ö†Ô∏è  Este comando:"
    echo "  ‚Ä¢ Elimina los directorios de worktree"
    echo "  ‚Ä¢ Mantiene las branches en los repos principales"
    echo "  ‚Ä¢ NO elimina commits ni cambios commiteados"
}

if [ -z "$WORKSPACE_PATTERN" ]; then
    show_help
    exit 1
fi

# Buscar workspace que coincida con el patr√≥n
WORKSPACE_NAME=$(find_matching_workspace "$WORKSPACE_PATTERN" "$WORKSPACES_DIR")
if [ $? -ne 0 ]; then
    exit 1
fi

# Determinar directorio del workspace
WORKSPACE_DIR="$WORKSPACES_DIR/$WORKSPACE_NAME"
BRANCH_NAME="$(get_branch_name "$WORKSPACE_NAME")"

if [ ! -d "$WORKSPACE_DIR" ]; then
    die "Workspace no existe: $WORKSPACE_NAME"
fi

# Mostrar qu√© se va a eliminar
warning "‚ö†Ô∏è  Vas a limpiar el workspace: ${COLOR_BOLD}$WORKSPACE_NAME${COLOR_RESET} (branch: ${COLOR_CYAN}$BRANCH_NAME${COLOR_RESET})"
echo ""
echo "Repos afectados:"

repos=$(find_repos_in_workspace "$WORKSPACE_DIR")
has_repos=false
has_uncommitted_changes=false

echo "$repos" | while read -r repo_rel_path; do
    if [ -n "$repo_rel_path" ]; then
        has_repos=true
        worktree_path="$WORKSPACE_DIR/$repo_rel_path"
        echo "  ‚Ä¢ ${COLOR_CYAN}$repo_rel_path${COLOR_RESET}"

        # Verificar si hay cambios sin commitear
        if git_has_uncommitted_changes "$worktree_path"; then
            warning "    ‚ö†Ô∏è  TIENE CAMBIOS SIN COMMITEAR"
            has_uncommitted_changes=true
        fi
    fi
done

if [ -z "$repos" ] || [ "$repos" = "" ]; then
    echo "  ${COLOR_DIM}(No hay repos en este workspace)${COLOR_RESET}"
fi

echo ""
echo "Esto eliminar√° los worktrees pero mantendr√° las branches en los repos principales."
echo ""

if [ "$FORCE" = false ]; then
    read -p "¬øContinuar? (s/n) " -n 1 -r
    echo

    if [[ ! $REPLY =~ ^[Ss]$ ]]; then
        error "‚ùå Cancelado"
        exit 1
    fi
fi

# Eliminar cada worktree
echo ""
info "Limpiando worktrees..."

echo "$repos" | while read -r repo_rel_path; do
    if [ -n "$repo_rel_path" ]; then
        worktree_path="$WORKSPACE_DIR/$repo_rel_path"

        if [ -d "$worktree_path" ]; then
            echo "  ${COLOR_DIM}üóëÔ∏è  Eliminando worktree: $repo_rel_path${COLOR_RESET}"

            cd "$worktree_path"

            # Obtener el directorio del repo principal
            # Para git worktrees, .git puede ser un archivo o directorio
            if [ -f "$worktree_path/.git" ]; then
                # Es un worktree (archivo .git apunta al repo principal)
                MAIN_REPO=$(grep "gitdir:" "$worktree_path/.git" | cut -d' ' -f2 | sed 's|/\.git/worktrees/.*||')
            else
                # Es el repo principal o un caso especial
                MAIN_REPO=$(git rev-parse --git-common-dir 2>/dev/null | sed 's|/\.git.*||')
            fi

            # Volver al repo principal y eliminar worktree
            if [ -d "$MAIN_REPO" ]; then
                cd "$MAIN_REPO"
                git worktree remove "$worktree_path" --force 2>/dev/null || {
                    # Si falla, intentar eliminar manualmente
                    rm -rf "$worktree_path"
                    git worktree prune
                }
                success "     ‚úÖ Eliminado"
            else
                warning "     ‚ö†Ô∏è  No se pudo encontrar repo principal, eliminando directorio"
                rm -rf "$worktree_path"
            fi
        fi
    fi
done

# Eliminar directorio del workspace (y sus subdirectorios vac√≠os)
WORKSPACE_FULLY_REMOVED=true

if [ -d "$WORKSPACE_DIR" ]; then
    # Eliminar directorios vac√≠os recursivamente
    find "$WORKSPACE_DIR" -type d -empty -delete 2>/dev/null || true

    # Archivos/directorios que deben ignorarse al determinar si el workspace est√° vac√≠o
    # Configurable via WS_CLEAN_IGNORE en ~/.wsrc
    # Por defecto:
    # - .idea/, .vscode/, .kiro/, .cursor/: configuraci√≥n IDE/AI copiada por copy_workspace_config
    # - .playwright-mcp/: configuraci√≥n de herramientas testing
    # - AI.md, .ai/, docs/: symlinks creados por copy_workspace_config
    # - README.md: puede ser creado autom√°ticamente
    # Nota: .claude NO est√° por defecto porque puede contener commands/ personalizados
    local default_ignore=".idea .vscode .kiro .cursor .playwright-mcp AI.md .ai docs README.md"
    local ignore_list="${WS_CLEAN_IGNORE:-$default_ignore}"

    # Convertir a array
    read -ra ignore_patterns <<< "$ignore_list"

    # Contar archivos que NO deben ignorarse
    significant_files=0
    all_files=()
    significant_file_list=()

    # Leer todos los archivos en el directorio
    while IFS= read -r file; do
        [ -n "$file" ] && all_files+=("$file")
    done < <(ls -A "$WORKSPACE_DIR" 2>/dev/null)

    # Contar archivos significativos (que no est√°n en la lista de ignorados)
    for file in "${all_files[@]}"; do
        should_ignore=false
        file_path="$WORKSPACE_DIR/$file"

        # Ignorar enlaces simb√≥licos (pueden ser repos referenciados sin worktree)
        if [ -L "$file_path" ]; then
            should_ignore=true
        fi

        # Ignorar archivos en la lista de patrones
        if [ "$should_ignore" = false ]; then
            for pattern in "${ignore_patterns[@]}"; do
                if [ "$file" = "$pattern" ]; then
                    should_ignore=true
                    break
                fi
            done
        fi

        if [ "$should_ignore" = false ]; then
            ((significant_files++))
            significant_file_list+=("$file")
        fi
    done

    # Si no hay archivos significativos, eliminar todo el workspace
    if [ $significant_files -eq 0 ]; then
        rm -rf "$WORKSPACE_DIR"
    else
        # Hay archivos del usuario, no eliminar
        WORKSPACE_FULLY_REMOVED=false
    fi
fi

# Mensaje final coherente seg√∫n el resultado
echo ""
if [ "$WORKSPACE_FULLY_REMOVED" = true ]; then
    success "‚úÖ Workspace eliminado completamente: $WORKSPACE_NAME"
else
    warning "‚ö†Ô∏è  Workspace parcialmente limpiado: $WORKSPACE_NAME"
    echo ""
    echo "   El directorio NO se elimin√≥ porque contiene archivos/directorios adicionales:"
    for file in "${significant_file_list[@]}"; do
        echo "      ‚Ä¢ $file"
    done
    echo ""
    echo "   Ubicaci√≥n: $WORKSPACE_DIR"
    echo ""
    echo "   Si son worktrees que no se detectaron correctamente, elim√≠nalos manualmente:"
    echo "      rm -rf \"$WORKSPACE_DIR\""
fi

echo ""
info "üí° Las branches se mantienen en los repos principales:"
echo "   Branch: ${COLOR_CYAN}$BRANCH_NAME${COLOR_RESET}"
echo ""
echo "Para eliminar la branch de un repo:"
echo "  ${COLOR_DIM}cd $WORKSPACE_ROOT/<repo> && git branch -d $BRANCH_NAME${COLOR_RESET}"
