#!/bin/bash
# Limpia un workspace terminado (elimina worktrees pero mantiene branches)
# Soporta repos en subdirectorios

set -e

WORKSPACE_PATTERN=$1

# Detectar WORKSPACE_ROOT desde WS_TOOLS o por defecto
if [ -n "$WS_TOOLS" ]; then
    WORKSPACE_ROOT="${WS_TOOLS%/tools/workspace-tools}"
else
    # Fallback: asumir ubicaci√≥n est√°ndar
    WORKSPACE_ROOT=~/wrkspc.nubarchiva
fi
WORKSPACES_DIR=$WORKSPACE_ROOT/workspaces
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Cargar funciones compartidas
source "$SCRIPT_DIR/ws-common.sh"

# Funci√≥n de ayuda
show_help() {
    echo "Uso: ws clean [nombre|patr√≥n]"
    echo ""
    echo "Elimina los worktrees de un workspace pero mantiene las branches."
    echo ""
    echo "üí° Puedes usar coincidencia parcial para el nombre del workspace"
    echo ""
    echo "Ejemplos:"
    echo "  ws clean master"
    echo "  ws clean develop"
    echo "  ws clean nuba-8400"
    echo "  ws clean fac                     # b√∫squeda parcial"
    echo ""
    echo "‚ö†Ô∏è  Este comando:"
    echo "  ‚Ä¢ Elimina los directorios de worktree"
    echo "  ‚Ä¢ Mantiene las branches en los repos principales"
    echo "  ‚Ä¢ NO elimina commits ni cambios commiteados"
}

if [ -z "$WORKSPACE_PATTERN" ]; then
    show_help
    exit 1
fi

# Buscar workspace que coincida con el patr√≥n
WORKSPACE_NAME=$(find_matching_workspace "$WORKSPACE_PATTERN" "$WORKSPACES_DIR")
if [ $? -ne 0 ]; then
    exit 1
fi

# Determinar directorio del workspace
WORKSPACE_DIR=$WORKSPACES_DIR/$WORKSPACE_NAME
BRANCH_NAME=$(get_branch_name "$WORKSPACE_NAME")

if [ ! -d "$WORKSPACE_DIR" ]; then
    echo "‚ùå Workspace no existe: $WORKSPACE_NAME"
    exit 1
fi

# Mostrar qu√© se va a eliminar
echo "‚ö†Ô∏è  Vas a limpiar el workspace: $WORKSPACE_NAME (branch: $BRANCH_NAME)"
echo ""
echo "Repos afectados:"

repos=$(find_repos_in_workspace "$WORKSPACE_DIR")
has_repos=false
has_uncommitted_changes=false

echo "$repos" | while read -r repo_rel_path; do
    if [ -n "$repo_rel_path" ]; then
        has_repos=true
        worktree_path="$WORKSPACE_DIR/$repo_rel_path"
        echo "  ‚Ä¢ $repo_rel_path"

        # Verificar si hay cambios sin commitear
        if [ -d "$worktree_path" ]; then
            cd "$worktree_path"
            if [ -n "$(git status -s 2>/dev/null)" ]; then
                echo "    ‚ö†Ô∏è  TIENE CAMBIOS SIN COMMITEAR"
                has_uncommitted_changes=true
            fi
        fi
    fi
done

if [ -z "$repos" ] || [ "$repos" = "" ]; then
    echo "  (No hay repos en este workspace)"
fi

echo ""
echo "Esto eliminar√° los worktrees pero mantendr√° las branches en los repos principales."
echo ""
read -p "¬øContinuar? (s/n) " -n 1 -r
echo

if [[ ! $REPLY =~ ^[Ss]$ ]]; then
    echo "‚ùå Cancelado"
    exit 1
fi

# Eliminar cada worktree
echo ""
echo "Limpiando worktrees..."

echo "$repos" | while read -r repo_rel_path; do
    if [ -n "$repo_rel_path" ]; then
        worktree_path="$WORKSPACE_DIR/$repo_rel_path"

        if [ -d "$worktree_path" ]; then
            echo "  üóëÔ∏è  Eliminando worktree: $repo_rel_path"

            cd "$worktree_path"

            # Obtener el directorio del repo principal
            # Para git worktrees, .git puede ser un archivo o directorio
            if [ -f "$worktree_path/.git" ]; then
                # Es un worktree (archivo .git apunta al repo principal)
                MAIN_REPO=$(grep "gitdir:" "$worktree_path/.git" | cut -d' ' -f2 | sed 's|/\.git/worktrees/.*||')
            else
                # Es el repo principal o un caso especial
                MAIN_REPO=$(git rev-parse --git-common-dir 2>/dev/null | sed 's|/\.git.*||')
            fi

            # Volver al repo principal y eliminar worktree
            if [ -d "$MAIN_REPO" ]; then
                cd "$MAIN_REPO"
                git worktree remove "$worktree_path" --force 2>/dev/null || {
                    # Si falla, intentar eliminar manualmente
                    rm -rf "$worktree_path"
                    git worktree prune
                }
                echo "     ‚úÖ Eliminado"
            else
                echo "     ‚ö†Ô∏è  No se pudo encontrar repo principal, eliminando directorio"
                rm -rf "$worktree_path"
            fi
        fi
    fi
done

# Eliminar directorio del workspace (y sus subdirectorios vac√≠os)
if [ -d "$WORKSPACE_DIR" ]; then
    # Eliminar directorios vac√≠os recursivamente
    find "$WORKSPACE_DIR" -type d -empty -delete 2>/dev/null || true

    # Verificar qu√© archivos quedan
    remaining_files=$(ls -A "$WORKSPACE_DIR" 2>/dev/null)

    # Si est√° vac√≠o o solo queda README.md (que creamos nosotros), eliminar todo
    if [ -z "$remaining_files" ]; then
        rm -rf "$WORKSPACE_DIR"
    elif [ "$remaining_files" = "README.md" ]; then
        # Solo queda el README que creamos, eliminar todo
        rm -rf "$WORKSPACE_DIR"
    else
        echo ""
        echo "‚ö†Ô∏è  El workspace tiene archivos adicionales. No se elimin√≥ el directorio."
        echo "   Revisa: $WORKSPACE_DIR"
        echo "   Archivos restantes: $remaining_files"
    fi
fi

echo ""
echo "‚úÖ Workspace limpiado: $WORKSPACE_NAME"
echo ""
echo "üí° La branch se mantiene en los repos principales:"
echo "   Branch: $BRANCH_NAME"
echo ""
echo "Para ver branches en un repo:"
echo "  cd $WORKSPACE_ROOT/<repo> && git branch -a"
